<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OS WarSim v60.1: Wiki & Menu Update</title>
    <style>
        /* --- GENERAL SETTINGS --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #0f0f13;
            background-image: radial-gradient(#1f1f23 1px, transparent 1px);
            background-size: 20px 20px;
            color: #e0e0e0;
            margin: 0; padding: 0; height: 100vh; width: 100vw; overflow: hidden;
            user-select: none;
        }

        /* --- TASKBAR --- */
        .taskbar {
            width: 100%; height: 50px; background-color: #111; border-bottom: 2px solid #333;
            display: flex; align-items: center; justify-content: space-between; padding: 0 20px;
            box-sizing: border-box; z-index: 10000; position: fixed; top: 0; left: 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        h1 { margin: 0; font-size: 16px; color: #fff; letter-spacing: 1px; font-weight: 700; text-transform: uppercase; }
        .controls { display: flex; gap: 8px; align-items: center;}
        button {
            padding: 6px 12px; font-size: 11px; cursor: pointer; background-color: #2c3e50; color: #fff;
            border: 1px solid #34495e; border-radius: 4px; font-weight: 600; transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        button:hover { background-color: #3b536b; transform: translateY(-1px); }
        button:active { transform: translateY(1px); }
        #btn-pause { width: 70px; }
        .running #btn-pause { background-color: #c0392b; border-color: #e74c3c; } 
        .paused #btn-pause { background-color: #27ae60; border-color: #2ecc71; }
        .speed-indicator { font-size: 12px; color: #00d2d3; min-width: 50px; text-align: center; font-family: 'Consolas', monospace; font-weight: bold; }

        /* --- WINDOWS --- */
        .draggable-window {
            position: absolute; background-color: rgba(20, 20, 20, 0.95); border: 1px solid #444; border-radius: 6px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.6); display: flex; flex-direction: column; 
            resize: both; overflow: hidden; min-width: 200px; min-height: 150px;
            backdrop-filter: blur(5px);
        }
        .window-header {
            height: 28px; background: linear-gradient(to bottom, #333, #222); border-bottom: 1px solid #444;
            display: flex; align-items: center; padding: 0 8px; cursor: move; flex-shrink: 0;
        }
        .window-title { font-size: 11px; font-weight: bold; color: #eee; flex-grow: 1; text-align: center; pointer-events: none; letter-spacing: 0.5px; }
        .window-controls { display: flex; gap: 6px; }
        .win-btn { width: 10px; height: 10px; border-radius: 50%; background-color: #555; }
        .win-btn.close { background-color: #ff5f56; border: 1px solid #e0443e; }
        .window-content { padding: 0; display: flex; flex-direction: column; flex-grow: 1; width: 100%; height: 100%; position: relative; background: #000;}

        /* --- WAR BOARD --- */
        .board-wrapper { position: relative; width: 100%; height: 100%; flex-grow: 1; background:#000; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        #war-canvas { position: absolute; top:0; left:0; z-index: 1; }
        #air-layer { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 200; }
        #fx-layer { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 300; }
        #labels-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 999; }
        
        #nuke-overlay {
            position: fixed; top:0; left:0; width:100vw; height:100vh; background:white; pointer-events: none;
            opacity: 0; z-index: 99999;
        }

        /* --- HOI4 STYLE LABELS & BARS --- */
        .troop-label {
            position: absolute; color: white; font-weight: bold; font-family: 'Consolas', monospace;
            font-size: 10px; text-shadow: 0px 0px 3px rgba(0,0,0,1); pointer-events: none; 
            transform: translate(-50%, -50%); white-space: nowrap; z-index: 999; 
            padding: 2px 4px; border-radius: 3px; border: 1px solid rgba(255,255,255,0.6);
            box-shadow: 0 2px 5px rgba(0,0,0,0.8); transition: top 0.2s linear, left 0.2s linear; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            gap: 2px; padding-bottom: 2px;
        }

        .planning-bar-track {
            width: 90%; height: 3px; background: rgba(0,0,0,0.6); 
            border-radius: 2px; overflow: hidden; margin-top: 1px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .planning-bar-fill {
            height: 100%; width: 0%; 
            background: #2ecc71; 
            box-shadow: 0 0 4px #2ecc71;
            transition: width 0.3s linear, background-color 0.3s;
        }

        .regrouping .planning-bar-fill {
            background: #f1c40f; 
            box-shadow: 0 0 4px #f1c40f;
        }

        .attacking .planning-bar-fill {
            background-color: #fff !important; 
            box-shadow: 0 0 8px #fff, 0 0 15px #e74c3c !important;
            animation: bar-flash 0.2s infinite alternate;
        }
        @keyframes bar-flash { from { opacity: 1; } to { opacity: 0.5; } }

        /* --- LOG PANEL --- */
        #log-container {
            width: 100%; height: 100%; background: #000; overflow-y: auto; 
            font-family: 'Consolas', monospace; font-size: 11px; padding: 5px; box-sizing: border-box;
            display: flex; flex-direction: column-reverse; 
        }
        .log-entry { margin-bottom: 2px; padding: 2px 4px; border-left: 3px solid #555; background: #111; color: #bbb; }
        .log-war { border-color: #e74c3c; color: #ffcccc; }
        .log-peace { border-color: #2ecc71; color: #ccffcc; }
        .log-nuke { border-color: #f1c40f; color: #ffffaa; background: #333; font-weight: bold; }
        .log-rebel { border-color: #9b59b6; color: #eebbff; }
        .log-blitz { border-color: #e67e22; color: #ffdcb8; font-weight: bold; background: #2e1d00; }
        .log-annihilation { border-color: #000; color: #fff; background: #500; font-weight: bold; border: 1px solid red; }

        /* --- FLOATING TEXTS --- */
        .blitz-text {
            position: absolute; color: #e74c3c; font-weight: 900; font-family: 'Arial Black', sans-serif;
            font-size: 14px; text-shadow: 0 0 5px red; z-index: 2000; pointer-events: none;
            animation: pop-up-fade 2s forwards; transform: translate(-50%, -50%);
            white-space: nowrap; border: 1px solid #e74c3c; background: rgba(0,0,0,0.7); padding: 2px 6px;
        }
        .panic-text {
            position: absolute; font-family: 'Courier New', monospace; font-weight: bold;
            font-size: 16px; color: #ff0000; background: black; border: 1px solid red;
            padding: 4px 8px; z-index: 2001; pointer-events: none;
            animation: shake-fade 2.5s forwards; transform: translate(-50%, -50%);
        }
        @keyframes pop-up-fade {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -150%) scale(1); opacity: 0; }
        }
        @keyframes shake-fade {
            0% { transform: translate(-50%, -50%) rotate(0deg); opacity: 1; }
            25% { transform: translate(-52%, -48%) rotate(-5deg); }
            50% { transform: translate(-48%, -52%) rotate(5deg); }
            75% { transform: translate(-52%, -52%) rotate(-5deg); opacity: 0.8; }
            100% { transform: translate(-50%, -60%) rotate(0deg); opacity: 0; }
        }

        /* --- ECONOMY & BARS --- */
        .chart-container { width: 100%; height: 100%; background-color: #111; position: relative; padding: 5px; box-sizing: border-box; overflow-y: auto; }
        .bar-wrapper { position: relative; width: 100%; height: 35px; margin-bottom: 4px; display: flex; align-items: center; background: #222; padding: 2px; border-radius: 4px; border: 1px solid #333; }
        .bar-info { width: 35%; display: flex; flex-direction: column; padding-left: 5px; justify-content: center; }
        .bar-name { font-size: 11px; font-weight: bold; color: #fff; }
        .bar-money { font-size: 10px; color: #2ecc71; font-family: monospace; }
        .bar-actions { flex-grow: 1; display: flex; justify-content: flex-end; align-items: center; padding-right: 5px; gap: 5px;}
        .nuke-progress { width: 40px; height: 6px; background: #333; border-radius: 2px; overflow: hidden; position: relative; border: 1px solid #555; }
        .nuke-fill { height: 100%; background: #f1c40f; width: 0%; transition: width 0.5s; }
        .btn-buy-factory { background-color: #34495e; color: white; border: none; padding: 3px 6px; font-size: 9px; border-radius: 3px; cursor: pointer; border: 1px solid #444; }
        .btn-buy-factory:hover { background-color: #2ecc71; }
        .factory-count { font-size: 10px; color: #aaa; font-weight: bold; }

        /* --- STAT BARS --- */
        .stat-bar-wrapper { position: absolute; left: 5px; width: calc(100% - 10px); height: 20px; transition: top 0.4s ease-in-out; display: flex; align-items: center; }
        .stat-bar-label { width: 30px; font-size: 9px; font-weight: bold; color: #888; text-align: right; margin-right: 5px; }
        .stat-bar-track { flex-grow: 1; height: 10px; background-color: #222; border-radius: 2px; position: relative; overflow: hidden; }
        .stat-bar-fill { height: 100%; position: absolute; left: 0; top: 0; display: flex; align-items: center; padding-left: 4px; }
        .stat-bar-value { color: #fff; font-size: 8px; font-weight: bold; text-shadow: 0 0 2px #000; z-index: 10; }

        .side-by-side-charts { display: flex; gap: 5px; width: 100%; height: 100%; box-sizing: border-box; padding: 5px; }
        .small-chart-container { flex: 1; height: 100%; background-color: #111; border: 1px solid #333; padding: 2px; border-radius: 4px; display: flex; flex-direction: column; }
        .chart-title-small { font-size: 9px; color: #666; margin-bottom: 2px; font-weight: bold; text-transform: uppercase; text-align: center; }

        /* --- COLORS --- */
        .bg-1 { background-color: #e74c3c !important; } .lbl-1 { background-color: rgba(192, 57, 43, 0.9); border-color: #fff; }
        .bg-2 { background-color: #3498db !important; } .lbl-2 { background-color: rgba(41, 128, 185, 0.9); border-color: #fff; }
        .bg-3 { background-color: #2ecc71 !important; } .lbl-3 { background-color: rgba(39, 174, 96, 0.9); border-color: #fff; }
        .bg-4 { background-color: #f1c40f !important; } .lbl-4 { background-color: rgba(243, 156, 18, 0.9); color:black; text-shadow:none; border-color: #fff; }
        .bg-5 { background-color: #1abc9c !important; } .lbl-5 { background-color: rgba(22, 160, 133, 0.9); border-color: #fff; }
        .bg-6 { background-color: #9b59b6 !important; } .lbl-6 { background-color: rgba(142, 68, 173, 0.9); border-color: #fff; }
        .bg-7 { background-color: #e67e22 !important; } .lbl-7 { background-color: rgba(211, 84, 0, 0.9); border-color: #fff; }
        .bg-8 { background-color: #ff7979 !important; } .lbl-8 { background-color: rgba(235, 77, 75, 0.9); border-color: #fff; }
        .bg-9 { background-color: #7f8c8d !important; } .lbl-9 { background-color: rgba(127, 140, 141, 0.9); border-color: #fff; }
        
        /* --- TERRAIN COLORS --- */
        .terrain-mountain { background-color: rgba(0,0,0,0.4); } 
        .terrain-forest { background-color: rgba(0,100,0,0.2); } 

        #victory-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 99999; display: none; justify-content: center; align-items: center; flex-direction: column; }
        #victory-text { font-size: 50px; font-weight: 800; color: white; margin-bottom: 30px; text-shadow: 0 0 30px rgba(255,255,255,0.5); letter-spacing: 2px;}

        /* --- SETUP SCREEN STYLES --- */
        #setup-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.98); z-index: 999999;
            display: flex; justify-content: center; align-items: center;
        }
        .setup-box {
            background: #111; border: 1px solid #333; padding: 20px; border-radius: 8px;
            box-shadow: 0 0 50px rgba(230, 126, 34, 0.2); width: 600px;
        }
        .era-box {
            flex: 1; background: #1a1a1a; padding: 10px; border-radius: 4px; border: 1px solid #333;
        }
        .era-box h3 { margin: 0 0 10px 0; font-size: 14px; text-align: center; letter-spacing: 1px; }
        .input-group { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .input-group label { font-size: 11px; color: #aaa; }
        .input-group input { 
            width: 50px; background: #222; border: 1px solid #444; color: white; 
            text-align: center; padding: 2px; font-family: monospace;
        }
        .note { font-size: 9px; color: #666; font-style: italic; text-align: center; margin-top: 5px; }
        .input-group input:focus { border-color: #e67e22; outline: none; }
        #btn-start-game:hover { background: #2ecc71; transform: scale(1.02); transition: 0.2s; }
 
        /* --- LOGO STÄ°LÄ° --- */
        #menu-logo {
            display: block;           /* Blok element yap */
            margin: 0 auto 20px auto; /* Ortala ve alttan 20px boÅŸluk bÄ±rak */
            max-width: 100%;          /* Kutudan taÅŸmasÄ±nÄ± engelle */
            height: auto;             /* OranÄ±nÄ± koru */
            max-height: 200px;        /* Ã‡ok devasa olmasÄ±nÄ± engelle (Ä°steÄŸe baÄŸlÄ±) */
            border-radius: 4px;       /* KÃ¶ÅŸeleri hafif yuvarla */
            box-shadow: 0 0 20px rgba(0,0,0,0.5); /* Hafif gÃ¶lge ekle */
            border: 1px solid #333;
        }

        /* --- WIKI SCREEN STYLES --- */
        #wiki-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 1000000;
            display: none; justify-content: center; align-items: center;
        }
        .wiki-box {
            background: #151515; border: 1px solid #444; padding: 30px; border-radius: 8px;
            width: 700px; max-height: 80vh; overflow-y: auto;
            box-shadow: 0 0 50px rgba(52, 152, 219, 0.2);
            color: #ccc;
        }
        .wiki-box h1 { color: #3498db; border-bottom: 1px solid #333; padding-bottom: 10px; margin-bottom: 20px; font-size: 24px; }
        .wiki-box p { line-height: 1.6; margin-bottom: 15px; font-size: 14px; }
        .wiki-box h2 { color: #e67e22; font-size: 18px; margin-top: 20px; margin-bottom: 10px; }
        #btn-close-wiki {
            margin-top: 20px; background: #e74c3c; border-color: #c0392b; width: 100%; padding: 10px; font-size: 14px;
        }
        #btn-open-wiki {
            width: 100%; margin-top: 10px; background: #34495e; border: 1px solid #444; padding: 10px; color: #ccc;
        }
        #btn-open-wiki:hover { background: #2c3e50; color: white; }
    </style>
</head>
<body class="running">

    <div id="nuke-overlay"></div>

    <div id="victory-screen">
        <div id="victory-text">WINNER: RED</div>
        <button id="btn-restart" style="font-size:20px; padding:15px 40px; background:#27ae60; border-color:#2ecc71;">NEW SIMULATION</button>
    </div>

    <div id="wiki-screen">
        <div class="wiki-box">
            <h1>OS WARSIM KILAVUZU</h1>
            
            <p><strong>HoÅŸgeldiniz!</strong> Buraya oyunun hikayesi, kurallarÄ± veya taktikleri gelecek.</p>
            
            <h2>NasÄ±l OynanÄ±r?</h2>
            <p>Åžu anda bu alan yapÄ±m aÅŸamasÄ±ndadÄ±r. Daha sonra buraya detaylÄ± metin eklenecektir.</p>

            <p><em>(Text placeholder - Wiki content goes here)</em></p>

            <button id="btn-close-wiki">KAPAT / CLOSE</button>
        </div>
    </div>

    <div class="taskbar">
        <div style="display:flex; align-items:center;">
            <h1>OS WarSim <span style="color:#e67e22; font-size:12px;">v60.1 WIKI EDITION</span></h1>
            <span style="margin: 0 15px; color: #444;">|</span>
            <div style="display:flex; gap:10px;">
                <div id="date-display" style="font-family: 'Courier New', monospace; font-weight: bold; color: #fff; font-size: 14px; background: #222; padding: 2px 8px; border-radius: 4px; border: 1px solid #444;">1914-01-01</div>
                <div id="era-display" style="font-family: 'Segoe UI', sans-serif; font-weight: bold; color: #f1c40f; font-size: 12px; background: #333; padding: 3px 8px; border-radius: 4px; text-transform: uppercase; letter-spacing: 1px;">TRENCH WARFARE</div>
            </div>
        </div>
        <div class="controls">
            <button id="btn-slower">Â« Slower</button>
            <span id="speed-display" class="speed-indicator">60ms</span>
            <button id="btn-faster">Faster Â»</button>
            <div style="width:10px;"></div>
            <button id="btn-reset">Reset</button>
            <button id="btn-pause">Pause</button>
            <div style="width:10px;"></div>
            <button id="btn-back-menu" style="background-color:#d35400; border-color:#e67e22;">âš  MENU</button>
        </div>
    </div>

    <div id="win-analysis" class="draggable-window" style="top: 70px; left: 20px; z-index: 10; width: 320px; height: 200px;">
        <div class="window-header"><div class="window-controls"><div class="win-btn close"></div></div><div class="window-title">Statistics</div></div>
        <div class="window-content">
            <div class="side-by-side-charts">
                <div class="small-chart-container"><div class="chart-title-small">Population</div><div id="pop-bar-container" class="chart-container" style="overflow:hidden;"></div></div>
                <div class="small-chart-container"><div class="chart-title-small">Casualties</div><div id="loss-bar-container" class="chart-container" style="overflow:hidden;"></div></div>
            </div>
        </div>
    </div>

<div id="setup-screen">
    <div class="setup-box" style="width: 700px;">
        
        <img src="logo.png" id="menu-logo" alt="Oyun Logosu">
        <h1 style="color:#e67e22; text-align:center; margin-bottom:15px; border-bottom:1px solid #444; padding-bottom:10px;">OS WARSIM: CONFIG</h1>
        
        <div style="display:flex; gap:10px; margin-bottom:15px; justify-content:center; background:#222; padding:10px; border-radius:4px; border:1px solid #444;">
            <div class="input-group" style="width:150px;">
                <label style="color:#3498db; font-weight:bold;">Deniz SayÄ±sÄ±:</label>
                <input type="number" id="sea-count" value="15" min="0" max="50">
            </div>
            <div class="input-group" style="width:150px;">
                <label style="color:#3498db; font-weight:bold;">Deniz Boyutu:</label>
                <input type="number" id="sea-size" value="5" min="1" max="15">
            </div>
        </div>

        <div style="display:flex; gap:10px; margin-bottom:15px;">
            <div class="era-box">
                <h3 style="color:#f1c40f">TRENCH (1914)</h3>
                <div class="input-group"><label>Min (%):</label><input type="number" id="tr-min" value="90"></div>
                <div class="input-group"><label>Max (%):</label><input type="number" id="tr-max" value="110"></div>
            </div>
            <div class="era-box">
                <h3 style="color:#e67e22">MOBILE</h3>
                <div class="input-group"><label>YÄ±l:</label><input type="number" id="mob-year" value="1936"></div>
                <div class="input-group"><label>Min (%):</label><input type="number" id="mob-min" value="80"></div>
                <div class="input-group"><label>Max (%):</label><input type="number" id="mob-max" value="150"></div>
            </div>
            <div class="era-box">
                <h3 style="color:#3498db">MODERN</h3>
                <div class="input-group"><label>YÄ±l:</label><input type="number" id="mod-year" value="1950"></div>
                <div class="input-group"><label>Min (%):</label><input type="number" id="mod-min" value="50"></div>
                <div class="input-group"><label>Max (%):</label><input type="number" id="mod-max" value="200"></div>
            </div>
        </div>

        <h3 style="color:#ccc; border-bottom:1px solid #333; margin-bottom:10px; font-size:12px;">ADVANCED COMBAT MODIFIERS</h3>
        <div style="display:flex; gap:10px; margin-bottom:20px;">
            <div class="era-box" style="background:#222;">
                <div class="input-group">
                    <label style="color:#e74c3c">BaÅŸkent Bonusu (x):</label>
                    <input type="number" id="mod-capital" value="5.0" step="0.1">
                </div>
            </div>
            <div class="era-box" style="background:#222;">
                <div class="input-group">
                    <label style="color:#f1c40f">Siper DefansÄ± (x):</label>
                    <input type="number" id="mod-trench" value="1.5" step="0.1">
                </div>
            </div>
            <div class="era-box" style="background:#222;">
                <div class="input-group">
                    <label style="color:#3498db">KÃ¼Ã§Ã¼k Ãœlke (x):</label>
                    <input type="number" id="mod-small" value="3.0" step="0.1">
                </div>
            </div>
        </div>

        <button id="btn-start-game" style="width:100%; padding:12px; font-size:16px; background:#27ae60; color:white; border:none; border-radius:4px; cursor:pointer; font-weight:bold;">SÄ°MÃœLASYONU BAÅžLAT</button>
        <button id="btn-open-wiki">ðŸ“– WIKI / KILAVUZ</button>
    </div>
</div>
    <div id="win-log" class="draggable-window" style="bottom: 20px; right: 20px; z-index: 9; width: 350px; height: 200px;">
        <div class="window-header"><div class="window-controls"><div class="win-btn close"></div></div><div class="window-title">War Log</div></div>
        <div class="window-content">
            <div id="log-container">
                <div class="log-entry">System ready.</div>
            </div>
        </div>
    </div>

    <div id="win-war" class="draggable-window" style="top: 70px; left: 360px; z-index: 12; width: 800px; height: 800px;">
        <div class="window-header"><div class="window-controls"><div class="win-btn close"></div></div><div class="window-title">War Room (64x64)</div></div>
        <div class="window-content">
            <div class="board-wrapper">
                <canvas id="war-canvas"></canvas>
                <canvas id="air-layer"></canvas>
                <canvas id="fx-layer"></canvas> 
                <div id="labels-layer"></div> 
            </div>
        </div>
    </div>

    <div id="win-economy" class="draggable-window" style="top: 70px; left: 1030px; z-index: 10; width: 320px; height: 350px;">
        <div class="window-header"><div class="window-controls"><div class="win-btn close"></div></div><div class="window-title">Industry & Nukes</div></div>
        <div class="window-content"><div id="chart-container" class="chart-container"></div></div>
    </div>

    <div id="win-population" class="draggable-window" style="top: 440px; left: 1030px; z-index: 11; width: 320px; height: 320px;">
        <div class="window-header"><div class="window-controls"><div class="win-btn close"></div></div><div class="window-title">Demography Map</div></div>
        <div class="window-content" style="background:black;"><canvas id="pop-canvas" style="width:100%; height:100%;"></canvas></div>
    </div>

    <div id="win-demography" class="draggable-window" style="top: 290px; left: 20px; z-index: 10; width: 250px; height: 250px;">
        <div class="window-header"><div class="window-controls"><div class="win-btn close"></div></div><div class="window-title">Political Map</div></div>
        <div class="window-content" style="background:black;"><canvas id="demo-canvas" style="width:100%; height:100%;"></canvas></div>
    </div>

    <div id="win-factory" class="draggable-window" style="top: 290px; left: 280px; z-index: 10; width: 250px; height: 250px;">
        <div class="window-header"><div class="window-controls"><div class="win-btn close"></div></div><div class="window-title">Industrial Map</div></div>
        <div class="window-content" style="background:black;"><canvas id="factory-canvas" style="width:100%; height:100%;"></canvas></div>
    </div>

    <div id="win-draft" class="draggable-window" style="top: 550px; left: 20px; z-index: 10; width: 220px; height: 280px;">
        <div class="window-header"><div class="window-controls"><div class="win-btn close"></div></div><div class="window-title">Conscription Rates</div></div>
        <div class="window-content"><div id="draft-container" class="chart-container"></div></div>
    </div>
<script>
    document.addEventListener("DOMContentLoaded", function() {

        // --- PENCERE SÃœRÃœKLEME ---
        let zIndexCounter = 100;
        document.querySelectorAll('.draggable-window').forEach(win => {
            const header = win.querySelector('.window-header');
            win.addEventListener('mousedown', () => { win.style.zIndex = ++zIndexCounter; });
            header.addEventListener('mousedown', (e) => {
                e.preventDefault(); win.style.zIndex = ++zIndexCounter;
                let startX = e.clientX, startY = e.clientY;
                let startLeft = win.offsetLeft, startTop = win.offsetTop;
                function onMouseMove(e) { win.style.left = `${startLeft + (e.clientX - startX)}px`; win.style.top = `${startTop + (e.clientY - startY)}px`; }
                function onMouseUp() { document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); }
                document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp);
            });
        });

        // --- GLOBAL CONFIG ---
        let GAME_CONFIG = {
            trench: { min: 0.9, max: 1.1 },
            mobile: { start: 1936, min: 0.8, max: 1.5 },
            modern: { start: 1950, min: 0.5, max: 2.0 },
            modifiers: { capital: 5.0, trench_def: 1.5, small: 3.0 },
            sea: { count: 15, size: 5 } 
        };

        let ROWS = 64; let COLS = 64; 
        let currentSpeed = 60; 
        const GDP_PER_CELL = 2; 
        const INITIAL_POPULATION = 100000; 

        let FACTORY_COST = 10000; 
        let NUKE_COST_PER_TICK = 200;
        let NUKE_THRESHOLD = 400;
        let BASE_LOSS = 300; 
        const REBEL_PEACE_TIME = 60;

        const GREY = 0; 
        const OCEAN = 10; 
        
        const RED = 1; const BLUE = 2; const GREEN = 3; const YELLOW = 4;
        const CYAN = 5; const PURPLE = 6; const ORANGE = 7; const PINK = 8;
        const REBEL = 9;
        
        const TEAMS = [RED, BLUE, GREEN, YELLOW, CYAN, PURPLE, ORANGE, PINK]; 
        const BASE_TEAM_NAMES = { 1: "RED", 2: "BLUE", 3: "GREEN", 4: "YELLOW", 5: "CYAN", 6: "PURPLE", 7: "ORANGE", 8: "PINK", 9: "REBELS", 0: "NEUTRAL" };
        
        const COLOR_HEX = { 
            1: '#e74c3c', 2: '#3498db', 3: '#2ecc71', 4: '#f1c40f', 
            5: '#1abc9c', 6: '#9b59b6', 7: '#e67e22', 8: '#ff7979', 
            9: '#7f8c8d', 0: '#333333', 10: '#0b1d35' 
        };
        const COLOR_CLASS_BG = { 1: 'bg-1', 2: 'bg-2', 3: 'bg-3', 4: 'bg-4', 5: 'bg-5', 6: 'bg-6', 7: 'bg-7', 8: 'bg-8', 9: 'bg-9' };
        const COLOR_CLASS_LBL = { 1: 'lbl-1', 2: 'lbl-2', 3: 'lbl-3', 4: 'lbl-4', 5: 'lbl-5', 6: 'lbl-6', 7: 'lbl-7', 8: 'lbl-8', 9: 'lbl-9' };

        let CAPITALS = {};
        let demoCanvas, ctxDemo, popCanvas, ctxPop, factoryCanvas, ctxFact;
        let warGrid = [], demoGrid = [], occupationTime = [], populationGrid = [], factoryGrid = [], coreLevelGrid = [], permanentCoreGrid = []; 
        let planes = [], fleets = [], strategicPoints = [];
        let alliances = {}; 
        let intervalId = null, isPaused = false, gameTick = 0;
        let simDate = new Date("1914-01-01"); 
        let rebelSafeTimer = 0;
        let teamStats = {};
        let totalCasualties = {}; 
        const TERRAIN_PLAIN = 0;
        const TERRAIN_FOREST = 1;
        const TERRAIN_MOUNTAIN = 2;
        let terrainGrid = []; 
        let smallestTeamId = null;
        let animatingCells = {}; 
        let currentFrontData = {}; 
        let frontProgress = {}; 
        let fxParticles = []; 
        let modernEraTriggered = false;
        let liberationTriggered = false;

        const warCanvas = document.getElementById('war-canvas'); const ctxWar = warCanvas.getContext('2d');
        const airCanvas = document.getElementById('air-layer'); const ctxAir = airCanvas.getContext('2d');
        const fxCanvas = document.getElementById('fx-layer'); const ctxFx = fxCanvas.getContext('2d');
        const chartContainerEl = document.getElementById('chart-container');
        const logContainer = document.getElementById('log-container');
        const popBarContainer = document.getElementById('pop-bar-container');
        const lossBarContainer = document.getElementById('loss-bar-container');
        const labelsLayerEl = document.getElementById('labels-layer');
        const victoryScreen = document.getElementById('victory-screen');
        const victoryText = document.getElementById('victory-text');

        document.getElementById('btn-reset').addEventListener('click', resetGame);
        document.getElementById('btn-restart').addEventListener('click', resetGame);
        document.getElementById('btn-pause').addEventListener('click', togglePause);
        document.getElementById('btn-faster').addEventListener('click', () => changeSpeed(-20)); 
        document.getElementById('btn-slower').addEventListener('click', () => changeSpeed(20));
        
        // --- YENÄ° BUTON EVENTLERÄ° ---
        document.getElementById('btn-open-wiki').addEventListener('click', () => { document.getElementById('wiki-screen').style.display = 'flex'; });
        document.getElementById('btn-close-wiki').addEventListener('click', () => { document.getElementById('wiki-screen').style.display = 'none'; });
        document.getElementById('btn-back-menu').addEventListener('click', () => {
            clearInterval(intervalId);
            isPaused = true;
            document.getElementById('setup-screen').style.display = 'flex';
        });

        // --- BAÅžLATMA ---
        document.getElementById('btn-start-game').addEventListener('click', function() {
            GAME_CONFIG.trench.min = parseFloat(document.getElementById('tr-min').value) / 100;
            GAME_CONFIG.trench.max = parseFloat(document.getElementById('tr-max').value) / 100;
            GAME_CONFIG.mobile.start = parseInt(document.getElementById('mob-year').value);
            GAME_CONFIG.mobile.min = parseFloat(document.getElementById('mob-min').value) / 100;
            GAME_CONFIG.mobile.max = parseFloat(document.getElementById('mob-max').value) / 100;
            GAME_CONFIG.modern.start = parseInt(document.getElementById('mod-year').value);
            GAME_CONFIG.modern.min = parseFloat(document.getElementById('mod-min').value) / 100;
            GAME_CONFIG.modern.max = parseFloat(document.getElementById('mod-max').value) / 100;
            GAME_CONFIG.modifiers.capital = parseFloat(document.getElementById('mod-capital').value);
            GAME_CONFIG.modifiers.trench_def = parseFloat(document.getElementById('mod-trench').value);
            GAME_CONFIG.modifiers.small = parseFloat(document.getElementById('mod-small').value);
            GAME_CONFIG.sea.count = parseInt(document.getElementById('sea-count').value);
            GAME_CONFIG.sea.size = parseInt(document.getElementById('sea-size').value);

            ROWS = 64; COLS = 64; 
            document.querySelector('#win-war .window-title').innerText = `War Room (STANDARD)`;
            document.getElementById('setup-screen').style.display = 'none';
            createBoards(); 
        });

        // --- GOD MODE ---
        warCanvas.addEventListener('mousedown', function(e) {
            const rect = warCanvas.getBoundingClientRect();
            const scaleX = warCanvas.width / rect.width;
            const scaleY = warCanvas.height / rect.height;
            const x = Math.floor(((e.clientX - rect.left) * scaleX) / (warCanvas.width / COLS));
            const y = Math.floor(((e.clientY - rect.top) * scaleY) / (warCanvas.height / ROWS));

            if (x >= 0 && x < COLS && y >= 0 && y < ROWS) {
                if (warGrid[y][x] === OCEAN) return;
                let targetId = warGrid[y][x];
                if (targetId !== GREY) {
                    showFloatingText(e.clientX, e.clientY, "SMITE!", "panic-text");
                    spawnParticles((x * (warCanvas.width / COLS)) + 10, (y * (warCanvas.height / ROWS)) + 10, 'fire');
                    populationGrid[y][x] = Math.floor(populationGrid[y][x] * 0.1); 
                    warGrid[y][x] = GREY;
                    occupationTime[y][x] = 0;
                    if(factoryGrid[y][x]===1) { factoryGrid[y][x]=0; teamStats[targetId].factories--; }
                    addLog(`âš¡ GOD MODE: Smited region at [${x},${y}]`, 'annihilation');
                }
            }
        });

        function changeSpeed(delta) {
            let newSpeed = currentSpeed + delta;
            if (newSpeed < 20) newSpeed = 20; if (newSpeed > 500) newSpeed = 500;
            currentSpeed = newSpeed;
            document.getElementById('speed-display').innerText = currentSpeed + "ms";
            if (!isPaused) { clearInterval(intervalId); intervalId = setInterval(gameLoop, currentSpeed); }
        }

        function addLog(msg, type = 'normal') {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            if(type === 'war') entry.classList.add('log-war');
            if(type === 'peace') entry.classList.add('log-peace');
            if(type === 'nuke') entry.classList.add('log-nuke');
            if(type === 'rebel') entry.classList.add('log-rebel');
            if(type === 'blitz') entry.classList.add('log-blitz');
            if(type === 'annihilation') entry.classList.add('log-annihilation');
            let time = Math.floor(gameTick / 10);
            entry.innerText = `[T${time}] ${msg}`;
            logContainer.insertBefore(entry, logContainer.firstChild); 
            if(logContainer.children.length > 50) logContainer.removeChild(logContainer.lastChild);
        }

        function triggerNukeEffect() {}

        function spawnParticles(x, y, type) {
            const count = (type === 'fire') ? 10 : 30;
            for(let i=0; i<count; i++) {
                let color;
                if(type === 'confetti') {
                    const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6'];
                    color = colors[Math.floor(Math.random() * colors.length)];
                } else {
                    const colors = ['#e74c3c', '#e67e22', '#f1c40f', '#d35400'];
                    color = colors[Math.floor(Math.random() * colors.length)];
                }
                fxParticles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * (type === 'fire' ? 2 : 4),
                    vy: (Math.random() - 0.5) * 4 - (type === 'fire' ? 3 : 0),
                    life: 1.0, decay: 0.02 + Math.random() * 0.03, color: color, size: Math.random() * 3 + 1, type: type
                });
            }
        }

        function drawFX() {
            if(!ctxFx) return;
            const rect = fxCanvas.getBoundingClientRect();
            fxCanvas.width = rect.width; fxCanvas.height = rect.height;
            ctxFx.clearRect(0,0, fxCanvas.width, fxCanvas.height);
            for(let i = fxParticles.length - 1; i >= 0; i--) {
                let p = fxParticles[i];
                p.x += p.vx; p.y += p.vy; p.life -= p.decay;
                if(p.type === 'confetti') p.vy += 0.1; 
                ctxFx.globalAlpha = p.life; ctxFx.fillStyle = p.color;
                ctxFx.beginPath(); ctxFx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctxFx.fill();
                if(p.life <= 0) fxParticles.splice(i, 1);
            }
            ctxFx.globalAlpha = 1;
        }

        function getAllianceKey(id1, id2) { return id1 < id2 ? `${id1}-${id2}` : `${id2}-${id1}`; }
        function areAllies(id1, id2) {
            if(id1 === REBEL || id2 === REBEL || id1 === GREY || id2 === GREY || id1 === OCEAN || id2 === OCEAN) return false;
            let key = getAllianceKey(id1, id2); return alliances[key] && alliances[key] > 0;
        }

        function getCurrentFactoryCost(teamId) {
            let count = teamStats[teamId].factories || 0;
            return FACTORY_COST + (count * 1000); 
        }

        function getArmyForce(teamId, againstRealEnemy = true) {
            if (teamId === GREY || teamId === OCEAN) return 0;
            let stats = teamStats[teamId];
            if (!stats || stats.size === 0) return 0;

            let baseRate = 0.02;
            let factoryBonus = (stats.factories || 0) * 0.00025; 
            let finalRate = baseRate + factoryBonus;
            if (teamId === REBEL) finalRate = 0.15; 
            
            // Toplam Ulusal Ordu
            let totalNationalArmy = Math.floor(stats.totalPop * finalRate);
            
            // PAYDA HESABI (YENÄ° SÄ°STEM)
            let divider;
            if (againstRealEnemy) {
                divider = (stats.realFrontCount > 0) ? stats.realFrontCount : stats.totalFrontCount;
            } else {
                divider = stats.size * 2; 
            }
            
            if (!divider || divider < 1) divider = 1;

            let armyPerCell = Math.floor(totalNationalArmy / divider);
            return armyPerCell;
        }

        function getCountryCenter(teamId) {
            let tx = 0, ty = 0, count = 0;
            for(let y=0; y<ROWS; y++) for(let x=0; x<COLS; x++) if(warGrid[y][x] === teamId) { tx += x; ty += y; count++; }
            if(count === 0) return null;
            const rect = warCanvas.getBoundingClientRect(); 
            const cw = rect.width / COLS; const ch = rect.height / ROWS;
            return { x: (tx/count)*cw + cw/2, y: (ty/count)*ch + ch/2 };
        }

        function createBoards() {
            demoCanvas = document.getElementById('demo-canvas'); 
            if(demoCanvas) { demoCanvas.width = 640; demoCanvas.height = 640; ctxDemo = demoCanvas.getContext('2d'); }
            
            popCanvas = document.getElementById('pop-canvas'); 
            if(popCanvas) { popCanvas.width = 640; popCanvas.height = 640; ctxPop = popCanvas.getContext('2d'); }
            
            factoryCanvas = document.getElementById('factory-canvas'); 
            if(factoryCanvas) { factoryCanvas.width = 640; factoryCanvas.height = 640; ctxFact = factoryCanvas.getContext('2d'); }

            labelsLayerEl.innerHTML = ''; 
            chartContainerEl.innerHTML = ''; popBarContainer.innerHTML = ''; lossBarContainer.innerHTML = '';
            document.getElementById('draft-container').innerHTML = '';
            logContainer.innerHTML = '<div class="log-entry">System ready.</div>';
            
            animatingCells = {}; fxParticles = []; currentFrontData = {}; frontProgress = {};
            warGrid = []; demoGrid = []; occupationTime = []; populationGrid = []; factoryGrid = []; coreLevelGrid = []; permanentCoreGrid = [];
            planes = []; fleets = []; strategicPoints = []; alliances = {};
            teamStats = {}; totalCasualties = {}; liberationTriggered = false; 
            [...TEAMS, REBEL].forEach(id => { teamStats[id] = {gdp:0, totalPop:0, factories:0, money:0, nukeProgress:0, size:0, frontCount:0}; totalCasualties[id] = 0; });
            gameTick = 0; rebelSafeTimer = 0; victoryScreen.style.display = 'none';
            simDate = new Date("1914-01-01"); modernEraTriggered = false;
            document.getElementById('date-display').innerText = "1914-01-01";
            
            // 1. Ã–nce her yeri KARA (GREY) yap
            for (let y = 0; y < ROWS; y++) {
                let warRow=[], demoRow=[], timeRow=[], popRow=[], factRow=[], coreRow=[], permRow=[]; 
                for (let x = 0; x < COLS; x++) {
                    warRow.push(GREY); demoRow.push(GREY); timeRow.push(0); popRow.push(INITIAL_POPULATION); factRow.push(0); coreRow.push(0); permRow.push(false);
                }
                warGrid.push(warRow); demoGrid.push(demoRow); occupationTime.push(timeRow); populationGrid.push(popRow); factoryGrid.push(factRow); coreLevelGrid.push(coreRow); permanentCoreGrid.push(permRow); 
            }

            // 2. BaÅŸkentleri Belirle
            CAPITALS = { 
                1: {x: 6, y: 6}, 2: {x: 6, y: 56}, 3: {x: 56, y: 6}, 4: {x: 56, y: 56}, 
                5: {x: 32, y: 6}, 6: {x: 32, y: 56}, 7: {x: 6, y: 32}, 8: {x: 56, y: 32} 
            };
            window.BACKUP_CAPITALS = JSON.parse(JSON.stringify(CAPITALS));

            // 3. DENÄ°ZLERÄ° RASTGELE YERLEÅžTÄ°R
            let seasPlaced = 0;
            let attempts = 0;
            let seaCount = GAME_CONFIG.sea.count;
            let seaBaseRadius = GAME_CONFIG.sea.size;

            while(seasPlaced < seaCount && attempts < 1000) {
                attempts++;
                let cx = Math.floor(Math.random() * COLS);
                let cy = Math.floor(Math.random() * ROWS);
                let radius = seaBaseRadius + Math.floor(Math.random() * 3); 

                let safe = true;
                for(let id in CAPITALS) {
                    let cap = CAPITALS[id];
                    let dist = Math.hypot(cx - cap.x, cy - cap.y);
                    if(dist < radius + 6) { safe = false; break; }
                }

                if(safe) {
                    for(let y=cy-radius; y<=cy+radius; y++) {
                        for(let x=cx-radius; x<=cx+radius; x++) {
                            if(y>=0 && y<ROWS && x>=0 && x<COLS) {
                                if(Math.hypot(x-cx, y-cy) <= radius) {
                                    warGrid[y][x] = OCEAN; demoGrid[y][x] = OCEAN;
                                }
                            }
                        }
                    }
                    seasPlaced++;
                }
            }

            // 4. BaÅŸkentleri ve Ã‡evrelerini Ata
            for(let id in CAPITALS) {
                let cap = CAPITALS[id]; let tid = parseInt(id);
                for(let dy=-1; dy<=1; dy++) for(let dx=-1; dx<=1; dx++) {
                    let ny = cap.y + dy; let nx = cap.x + dx;
                    if(ny>=0 && ny<ROWS && nx>=0 && nx<COLS) {
                        if(warGrid[ny][nx] !== OCEAN) {
                            warGrid[ny][nx] = tid; demoGrid[ny][nx] = tid; 
                            coreLevelGrid[ny][nx] = 3; permanentCoreGrid[ny][nx] = true;
                        }
                    }
                }
            }

            // ARAZÄ° SÄ°STEMÄ° OLUÅžTURMA
            terrainGrid = [];
            for (let y = 0; y < ROWS; y++) {
                let tRow = [];
                for (let x = 0; x < COLS; x++) {
                    tRow.push(TERRAIN_PLAIN);
                }
                terrainGrid.push(tRow);
            }

            // DAÄžLARI VE ORMANLARI OLUÅžTUR
            for(let i=0; i<40; i++) { // 40 adet daÄŸ kÃ¼mesi
                let cx = Math.floor(Math.random() * COLS);
                let cy = Math.floor(Math.random() * ROWS);
                let size = Math.floor(Math.random() * 3) + 1;
                for(let y=cy-size; y<=cy+size; y++) {
                    for(let x=cx-size; x<=cx+size; x++) {
                        if(y>=0 && y<ROWS && x>=0 && x<COLS && Math.random() > 0.3) {
                            if(warGrid[y][x] !== OCEAN) terrainGrid[y][x] = TERRAIN_MOUNTAIN;
                        }
                    }
                }
            }

            for(let i=0; i<60; i++) { // 60 adet orman kÃ¼mesi
                let cx = Math.floor(Math.random() * COLS);
                let cy = Math.floor(Math.random() * ROWS);
                let size = Math.floor(Math.random() * 4) + 2;
                for(let y=cy-size; y<=cy+size; y++) {
                    for(let x=cx-size; x<=cx+size; x++) {
                        if(y>=0 && y<ROWS && x>=0 && x<COLS && Math.random() > 0.4) {
                            // DaÄŸlarÄ±n Ã¼zerine orman gelmesin
                            if(warGrid[y][x] !== OCEAN && terrainGrid[y][x] === TERRAIN_PLAIN) {
                                terrainGrid[y][x] = TERRAIN_FOREST;
                            }
                        }
                    }
                }
            }

            while(strategicPoints.length < 10) {
                let rx = Math.floor(Math.random() * COLS); let ry = Math.floor(Math.random() * ROWS);
                let safe = true;
                Object.values(CAPITALS).forEach(cap => { if (Math.abs(cap.x - rx) + Math.abs(cap.y - ry) < 4) safe = false; });
                if (strategicPoints.some(p => p.x === rx && p.y === ry)) safe = false;
                if (warGrid[ry][rx] === GREY) strategicPoints.push({x: rx, y: ry});
                else safe = false; 
            }

            TEAMS.forEach(t => { spawnPlane(t, 'FIGHTER'); spawnPlane(t, 'BOMBER'); });
            [...TEAMS, REBEL].forEach(teamId => { 
                let short = BASE_TEAM_NAMES[teamId].substring(0,3);
                createFactoryBarElement(teamId, BASE_TEAM_NAMES[teamId], chartContainerEl);
                createStatBarElement(teamId, short, popBarContainer, 'pop');
                createStatBarElement(teamId, short, lossBarContainer, 'loss');
                createDraftElement(teamId, BASE_TEAM_NAMES[teamId], document.getElementById('draft-container'));
            });
            calculateStats();
            
            requestAnimationFrame(renderLoop);
            clearInterval(intervalId);
            if (!isPaused) intervalId = setInterval(gameLoop, currentSpeed);
        }

        function updateCoreProgression() {
            let changes = [];
            TEAMS.forEach(teamId => {
                let level0 = []; let level1 = []; let level2 = []; 
                for(let y=0; y<ROWS; y++) for(let x=0; x<COLS; x++) {
                    if (!coreLevelGrid[y] || coreLevelGrid[y][x] === undefined) continue;
                    if (warGrid[y][x] === teamId && demoGrid[y][x] === teamId) {
                        let lvl = coreLevelGrid[y][x];
                        if (lvl === 1) level1.push({x,y});
                        if (lvl === 2) level2.push({x,y});
                    }
                    if (warGrid[y][x] === teamId && demoGrid[y][x] !== teamId) {
                        if (permanentCoreGrid[y][x] === true) continue; 
                        let hasCoreNeighbor = false;
                        let dirs = [[0,1],[0,-1],[1,0],[-1,0]];
                        for(let d of dirs) {
                            let ny=y+d[0], nx=x+d[1];
                            if(ny>=0 && ny<ROWS && nx>=0 && nx<COLS) {
                                if(demoGrid[ny][nx] === teamId && coreLevelGrid[ny][nx] > 0) { hasCoreNeighbor = true; break; }
                            }
                        }
                        if (hasCoreNeighbor) level0.push({x,y});
                    }
                }
                level2.sort(() => Math.random() - 0.5);
                for(let i=0; i<Math.min(2, level2.length); i++) changes.push({x:level2[i].x, y:level2[i].y, newLvl: 3, owner: teamId});
                level1.sort(() => Math.random() - 0.5);
                for(let i=0; i<Math.min(3, level1.length); i++) changes.push({x:level1[i].x, y:level1[i].y, newLvl: 2, owner: teamId});
                level0.sort(() => Math.random() - 0.5);
                for(let i=0; i<Math.min(4, level0.length); i++) changes.push({x:level0[i].x, y:level0[i].y, newLvl: 1, owner: teamId});
            });
            changes.forEach(c => {
                if (permanentCoreGrid[c.y][c.x] === true) return; 
                demoGrid[c.y][c.x] = c.owner;
                coreLevelGrid[c.y][c.x] = c.newLvl;
            });
        }

        function checkBlitz() {
            for(let key in currentFrontData) {
                let teams = key.split('-').map(Number);
                let t1 = teams[0]; let t2 = teams[1];
                let d1 = currentFrontData[key][t1];
                let d2 = currentFrontData[key][t2];
                if(!d1 || !d2 || d1.troops < 500 || d2.troops < 500) continue;

                let id1 = `front-${key}-${t1}`;
                let id2 = `front-${key}-${t2}`;
                if(!frontProgress[id1]) frontProgress[id1] = { val: 0, state: 'planning' };
                if(!frontProgress[id2]) frontProgress[id2] = { val: 0, state: 'planning' };

                if (d1.troops > d2.troops * 1.5) { frontProgress[id1].val += 0.8; frontProgress[id2].val = Math.max(0, frontProgress[id2].val - 1); } 
                else if (d2.troops > d1.troops * 1.5) { frontProgress[id2].val += 0.8; frontProgress[id1].val = Math.max(0, frontProgress[id1].val - 1); } 
                else { frontProgress[id1].val = Math.max(0, frontProgress[id1].val - 0.2); frontProgress[id2].val = Math.max(0, frontProgress[id2].val - 0.2); }

                [t1, t2].forEach(attacker => {
                    let id = `front-${key}-${attacker}`;
                    let defender = (attacker === t1) ? t2 : t1;
                    let atkData = (attacker === t1) ? d1 : d2;

                    if (frontProgress[id].val >= 100) {
                        frontProgress[id].state = 'attacking';
                        frontProgress[id].val += 1; 
                        if (frontProgress[id].val >= 140) {
                            let atkCenter = getCountryCenter(attacker);
                            let defCenter = getCountryCenter(defender);
                            if(atkCenter && defCenter) {
                                showFloatingText(atkCenter.x, atkCenter.y, "BLITZ!", "blitz-text");
                                addLog(`âš¡ ${BASE_TEAM_NAMES[attacker]} executed a planned offensive!`, 'blitz');
                                let enemyCells = [];
                                for(let y=0; y<ROWS; y++) for(let x=0; x<COLS; x++) if(warGrid[y][x] === defender) enemyCells.push({x,y});
                                if(enemyCells.length > 0) {
                                    let centerX = Math.floor(atkData.avgX); let centerY = Math.floor(atkData.avgY);
                                    enemyCells.sort((a,b) => (Math.abs(a.x - centerX) + Math.abs(a.y - centerY)) - (Math.abs(b.x - centerX) + Math.abs(b.y - centerY)));
                                    let takeCount = Math.floor(enemyCells.length * 0.15); 
                                    for(let i=0; i<takeCount; i++) {
                                        let c = enemyCells[i];
                                        setTimeout(() => {
                                            if(warGrid[c.y][c.x] === defender) {
                                                if (factoryGrid[c.y][c.x] === 1) {
                                                    if (defender !== GREY && defender !== OCEAN) teamStats[defender].factories = Math.max(0, teamStats[defender].factories - 1);
                                                    teamStats[attacker].factories++;
                                                }
                                                warGrid[c.y][c.x] = attacker; occupationTime[c.y][c.x] = 0;
                                                populationGrid[c.y][c.x] = Math.floor(populationGrid[c.y][c.x] * 0.90);
                                                startCaptureAnimation(c.x, c.y, defender, attacker, c.x, c.y);
                                                spawnParticles(c.x * (warCanvas.width/COLS) + (warCanvas.width/COLS)/2, c.y * (warCanvas.height/ROWS) + (warCanvas.height/ROWS)/2, 'fire');
                                            }
                                        }, i * 100); 
                                    }
                                }
                            }
                            frontProgress[id].val = 0; frontProgress[id].state = 'regroup'; 
                        }
                    } else { frontProgress[id].state = 'planning'; }
                });
            }
        }

        function showFloatingText(x, y, text, className) {
            const el = document.createElement('div');
            el.className = className; el.innerText = text; el.style.left = x + 'px'; el.style.top = y + 'px';
            labelsLayerEl.appendChild(el);
            setTimeout(() => { if(el.parentNode) el.parentNode.removeChild(el); }, 3000);
        }

        function renderLoop() { drawWarBoard(); drawPlanesAndDiplomacy(); drawFX(); requestAnimationFrame(renderLoop); }

        function startCaptureAnimation(x, y, oldC, newC, fromX, fromY) {
            let key = `${y}-${x}`;
            let dx = x - fromX; let dy = y - fromY;
            let dir = 'mid'; 
            if(dx === 1) dir = 'left'; else if(dx === -1) dir = 'right'; else if(dy === 1) dir = 'top'; else if(dy === -1) dir = 'bottom'; 
            animatingCells[key] = { oldC: oldC, newC: newC, progress: 0, dir: dir };
        }

        function drawWarBoard() {
            if(!ctxWar) return;
            const rect = warCanvas.getBoundingClientRect();
            warCanvas.width = rect.width; warCanvas.height = rect.height;
            const w = warCanvas.width; const h = warCanvas.height;
            const cellW = w / COLS; const cellH = h / ROWS;
            ctxWar.clearRect(0,0,w,h);

            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    let cx = x * cellW; let cy = y * cellH;
                    let key = `${y}-${x}`;
                    if (animatingCells[key]) {
                        let anim = animatingCells[key];
                        ctxWar.fillStyle = COLOR_HEX[anim.oldC]; ctxWar.fillRect(cx, cy, cellW, cellH);
                        ctxWar.fillStyle = COLOR_HEX[anim.newC];
                        let subW = cellW / 3; let subH = cellH / 3;
                        let frame = Math.floor(anim.progress); let order = [];
                        if (anim.dir === 'left') order = [[0,3,6], [1,4,7], [2,5,8]]; else if (anim.dir === 'right') order = [[2,5,8], [1,4,7], [0,3,6]]; else if (anim.dir === 'top') order = [[0,1,2], [3,4,5], [6,7,8]]; else if (anim.dir === 'bottom') order = [[6,7,8], [3,4,5], [0,1,2]]; else order = [[4], [0,2,6,8], [1,3,5,7]]; 
                        let step = Math.floor(frame / 3); 
                        for (let s = 0; s <= step && s < order.length; s++) { order[s].forEach(idx => { let r = Math.floor(idx / 3); let c = idx % 3; ctxWar.fillRect(cx + c*subW, cy + r*subH, subW+0.5, subH+0.5); }); }
                        anim.progress += 1; if (step >= order.length) delete animatingCells[key]; 
                    } else {
                        ctxWar.fillStyle = COLOR_HEX[warGrid[y][x]]; ctxWar.fillRect(cx, cy, cellW+0.5, cellH+0.5); 
                    }

                    if (terrainGrid[y][x] === TERRAIN_MOUNTAIN) {
                        ctxWar.fillStyle = "rgba(0, 0, 0, 0.35)"; 
                        ctxWar.fillRect(cx, cy, cellW, cellH);
                    } else if (terrainGrid[y][x] === TERRAIN_FOREST) {
                        ctxWar.fillStyle = "rgba(0, 50, 0, 0.25)"; 
                        ctxWar.fillRect(cx, cy, cellW, cellH);
                    }

                    if(strategicPoints.some(p => p.x === x && p.y === y)) { ctxWar.font = `${cellH/2}px Arial`; ctxWar.textAlign='center'; ctxWar.textBaseline='middle'; ctxWar.fillStyle = 'white'; ctxWar.fillText("â˜…", cx+cellW/2, cy+cellH/2); }
                    for(let t in CAPITALS) { if(CAPITALS[t].x === x && CAPITALS[t].y === y && warGrid[y][x] == t) { ctxWar.font = `${cellH/1.5}px Arial`; ctxWar.textAlign='center'; ctxWar.textBaseline='middle'; ctxWar.fillStyle = 'gold'; ctxWar.fillText("ðŸ‘‘", cx+cellW/2, cy+cellH/2); } }
                }
            }
        }

        function updatePlanes() {
            TEAMS.forEach(team => { if (Math.random() < 0.03) spawnPlane(team); });
            for (let i = planes.length - 1; i >= 0; i--) {
                let p = planes[i];
                let speedInGrid = (p.type === 'FIGHTER' ? 0.3 : 0.15); 
                if (p.type === 'FIGHTER') {
                    if (p.state === 'PATROL' || p.state === 'INTERCEPT') {
                        let nearestEnemy = null, minDst = 999;
                        planes.forEach(target => { if (target.team !== p.team && target.type === 'BOMBER') { if(!areAllies(p.team, target.team)) { let d = Math.hypot(target.gridX - p.gridX, target.gridY - p.gridY); if (d < minDst) { minDst = d; nearestEnemy = target; } } } });
                        if (nearestEnemy) { p.state = 'INTERCEPT'; p.targetPlane = nearestEnemy; p.targetGX = nearestEnemy.gridX; p.targetGY = nearestEnemy.gridY; } 
                        else if (p.state === 'INTERCEPT') p.state = 'RETURN'; 
                        else if (Math.random()<0.02) { p.targetGX = Math.random() * COLS; p.targetGY = Math.random() * ROWS; }
                    }
                }
                let tx = (p.state === 'RETURN') ? p.originGX : p.targetGX; let ty = (p.state === 'RETURN') ? p.originGY : p.targetGY;
                if (p.state === 'INTERCEPT' && p.targetPlane && planes.includes(p.targetPlane)) { tx = p.targetPlane.gridX; ty = p.targetPlane.gridY; }
                let dx = tx - p.gridX, dy = ty - p.gridY; let dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < speedInGrid) {
                    p.gridX = tx; p.gridY = ty;
                    if (p.state === 'ATTACK' && p.type === 'BOMBER') {
                        let gx = Math.floor(p.gridX); let gy = Math.floor(p.gridY);
                        if(gx >= 0 && gx < COLS && gy >= 0 && gy < ROWS && warGrid[gy][gx] !== GREY && warGrid[gy][gx] !== OCEAN) {
                            let targetTeam = warGrid[gy][gx];
                            if (!areAllies(p.team, targetTeam)) {
                                startCaptureAnimation(gx, gy, targetTeam, GREY, gx, gy); 
                                warGrid[gy][gx] = GREY; populationGrid[gy][gx] = Math.floor(populationGrid[gy][gx] * 0.5); occupationTime[gy][gx] = 0; 
                                if(factoryGrid[gy][gx]===1) { factoryGrid[gy][gx]=0; if(targetTeam!==GREY) teamStats[targetTeam].factories--; }
                            }
                        }
                        p.state = 'RETURN';
                    } else if (p.state === 'INTERCEPT' && p.type === 'FIGHTER') {
                        let target = p.targetPlane; 
                        if (target && planes.includes(target)) { let tIndex = planes.indexOf(target); if (tIndex > -1) { planes.splice(tIndex, 1); addLog("Air battle: Bomber downed!", "war"); } p.state = 'RETURN'; } else p.state = 'PATROL'; 
                    } else if (p.state === 'PATROL') { p.targetGX = Math.random() * COLS; p.targetGY = Math.random() * ROWS; } 
                    else if (p.state === 'RETURN') { planes.splice(i, 1); }
                } else { p.gridX += (dx / dist) * speedInGrid; p.gridY += (dy / dist) * speedInGrid; }
            }
        }

        // --- GEMÄ° (FLEET) MANTIÄžI ---
        function spawnFleet(teamId) {
            if (teamId === REBEL) return;
            if (teamStats[teamId].money < 500) return;

            let ports = [];
            for(let y=1; y<ROWS-1; y++) {
                for(let x=1; x<COLS-1; x++) {
                    if(warGrid[y][x] === teamId) {
                        let hasSea = false;
                        let seaX = x, seaY = y;
                        [[0,1],[0,-1],[1,0],[-1,0]].forEach(d => {
                            if(warGrid[y+d[0]][x+d[1]] === OCEAN) { hasSea=true; seaX=x+d[1]; seaY=y+d[0]; }
                        });
                        if(hasSea) ports.push({x: seaX, y: seaY});
                    }
                }
            }

            if(ports.length > 0) {
                let port = ports[Math.floor(Math.random() * ports.length)];
                let targetX = Math.floor(Math.random() * COLS);
                let targetY = Math.floor(Math.random() * ROWS);
                
                fleets.push({
                    team: teamId,
                    x: port.x, y: port.y,
                    tx: targetX, ty: targetY,
                    angle: 0
                });
                teamStats[teamId].money -= 500;
            }
        }

        function updateFleets() {
            TEAMS.forEach(team => { if (Math.random() < 0.05) spawnFleet(team); });

            for (let i = fleets.length - 1; i >= 0; i--) {
                let f = fleets[i];
                let speed = 0.15; 

                let dx = f.tx - f.x;
                let dy = f.ty - f.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                f.angle = Math.atan2(dy, dx);

                if (dist > speed) {
                    let nextX = f.x + (dx/dist) * speed;
                    let nextY = f.y + (dy/dist) * speed;
                    let gridX = Math.floor(nextX);
                    let gridY = Math.floor(nextY);

                    if (gridX >= 0 && gridX < COLS && gridY >= 0 && gridY < ROWS) {
                        if (warGrid[gridY][gridX] !== OCEAN) {
                            let coastalOwner = warGrid[gridY][gridX];
                            if (coastalOwner !== f.team && coastalOwner !== GREY && !areAllies(f.team, coastalOwner)) {
                                addLog(`âš“ NAVAL INVASION by ${BASE_TEAM_NAMES[f.team]}!`, 'annihilation');
                                warGrid[gridY][gridX] = f.team;
                                occupationTime[gridY][gridX] = 0;
                                startCaptureAnimation(gridX, gridY, coastalOwner, f.team, gridX, gridY);
                                spawnParticles(f.x * (warCanvas.width/COLS), f.y * (warCanvas.height/ROWS), 'fire');
                                
                                [[0,1],[0,-1],[1,0],[-1,0]].forEach(d => {
                                    let nx=gridX+d[1], ny=gridY+d[0];
                                    if(nx>=0 && nx<COLS && ny>=0 && ny<ROWS && warGrid[ny][nx] !== OCEAN) {
                                        warGrid[ny][nx] = f.team;
                                        occupationTime[ny][nx] = 0;
                                    }
                                });
                            }
                            fleets.splice(i, 1); 
                            continue;
                        } else {
                            f.x = nextX; f.y = nextY;
                        }
                    } else {
                        fleets.splice(i, 1);
                        continue;
                    }
                } else {
                    f.tx = Math.floor(Math.random() * COLS);
                    f.ty = Math.floor(Math.random() * ROWS);
                }

                for (let j = 0; j < fleets.length; j++) {
                    if (i !== j) {
                        let enemy = fleets[j];
                        if (Math.abs(f.x - enemy.x) < 1 && Math.abs(f.y - enemy.y) < 1) {
                            if (f.team !== enemy.team && !areAllies(f.team, enemy.team)) {
                                spawnParticles(f.x * (warCanvas.width/COLS), f.y * (warCanvas.height/ROWS), 'fire');
                                if (Math.random() < 0.5) { fleets.splice(i, 1); } 
                                else { fleets.splice(j, 1); if (j < i) i--; }
                                break;
                            }
                        }
                    }
                }
            }
        }

        function drawPlanesAndDiplomacy() {
            if(!ctxAir) return;
            const rect = airCanvas.getBoundingClientRect();
            airCanvas.width = rect.width; airCanvas.height = rect.height;
            const w = airCanvas.width; const h = airCanvas.height;
            const cellW = w / COLS; const cellH = h / ROWS;
            ctxAir.clearRect(0, 0, w, h);

            // --- YAMATO CLASS SHIP DRAWING ---
            fleets.forEach(f => {
                let px = f.x * cellW + cellW/2;
                let py = f.y * cellH + cellH/2;
                
                ctxAir.save();
                ctxAir.translate(px, py);
                ctxAir.rotate(f.angle); 
                
                let s = Math.min(cellW, cellH) * 0.8;

                ctxAir.fillStyle = COLOR_HEX[f.team]; 
                ctxAir.strokeStyle = "#000"; 
                ctxAir.lineWidth = 1;
                
                ctxAir.beginPath();
                ctxAir.moveTo(s * 0.8, 0); 
                ctxAir.lineTo(s * 0.2, -s * 0.25);
                ctxAir.lineTo(-s * 0.7, -s * 0.25); 
                ctxAir.lineTo(-s * 0.7, s * 0.25);
                ctxAir.lineTo(s * 0.2, s * 0.25);
                ctxAir.closePath();
                ctxAir.fill();
                ctxAir.stroke();

                ctxAir.fillStyle = "rgba(0,0,0,0.3)"; 
                ctxAir.fillRect(-s*0.2, -s*0.15, s*0.3, s*0.3); 
                
                ctxAir.fillStyle = "#333";
                ctxAir.beginPath(); ctxAir.arc(s*0.4, 0, s*0.08, 0, Math.PI*2); ctxAir.fill();
                ctxAir.beginPath(); ctxAir.moveTo(s*0.4, 0); ctxAir.lineTo(s*0.6, 0); ctxAir.stroke(); 
                ctxAir.beginPath(); ctxAir.arc(s*0.2, 0, s*0.08, 0, Math.PI*2); ctxAir.fill();
                ctxAir.beginPath(); ctxAir.arc(-s*0.4, 0, s*0.08, 0, Math.PI*2); ctxAir.fill();
                ctxAir.beginPath(); ctxAir.moveTo(-s*0.4, 0); ctxAir.lineTo(-s*0.6, 0); ctxAir.stroke(); 

                ctxAir.restore();
            });

            ctxAir.lineWidth = 2; ctxAir.setLineDash([10, 10]);
            for (let key in alliances) {
                if (alliances[key] > 0) {
                    let ids = key.split('-').map(Number);
                    let cap1 = CAPITALS[ids[0]]; let cap2 = CAPITALS[ids[1]];
                    if (cap1 && cap2 && warGrid[cap1.y][cap1.x] == ids[0] && warGrid[cap2.y][cap2.x] == ids[1]) {
                        let x1 = (cap1.x * cellW) + (cellW/2); let y1 = (cap1.y * cellH) + (cellH/2);
                        let x2 = (cap2.x * cellW) + (cellW/2); let y2 = (cap2.y * cellH) + (cellH/2);
                        ctxAir.strokeStyle = 'rgba(46, 204, 113, 0.5)'; ctxAir.beginPath(); ctxAir.moveTo(x1, y1); ctxAir.lineTo(x2, y2); ctxAir.stroke();
                        let mx = (x1+x2)/2; let my = (y1+y2)/2;
                        ctxAir.font = "12px Arial"; ctxAir.fillStyle = "#fff"; ctxAir.textAlign = "center"; ctxAir.fillText("â˜®ï¸", mx, my);
                    }
                }
            }
            ctxAir.setLineDash([]);

            planes.forEach(p => {
                let px = p.gridX * cellW + cellW/2; let py = p.gridY * cellH + cellH/2;
                let tx = (p.state === 'RETURN') ? p.originGX : p.targetGX; let ty = (p.state === 'RETURN') ? p.originGY : p.targetGY;
                if(p.state === 'INTERCEPT' && p.targetPlane) { tx = p.targetPlane.gridX; ty = p.targetPlane.gridY; }
                let angle = Math.atan2((ty*cellH) - (p.gridY*cellH), (tx*cellW) - (p.gridX*cellW));
                ctxAir.save(); ctxAir.translate(px, py); ctxAir.rotate(angle);
                let s = Math.min(cellW, cellH) * 0.5; 

                if (p.type === 'BOMBER') {
                    ctxAir.fillStyle = COLOR_HEX[p.team]; ctxAir.strokeStyle = "#fff"; ctxAir.lineWidth = 1;
                    ctxAir.beginPath(); ctxAir.moveTo(s*0.9, 0); ctxAir.lineTo(s*0.4, -s*0.2); ctxAir.lineTo(-s*0.6, -s*0.2); ctxAir.lineTo(-s*0.8, 0); ctxAir.lineTo(-s*0.6, s*0.2); ctxAir.lineTo(s*0.4, s*0.2); ctxAir.closePath(); ctxAir.fill(); ctxAir.stroke();
                    ctxAir.beginPath(); ctxAir.moveTo(s*0.2, -s*0.2); ctxAir.lineTo(-s*0.1, -s*1.1); ctxAir.lineTo(-s*0.3, -s*1.1); ctxAir.lineTo(-s*0.2, -s*0.2); ctxAir.moveTo(s*0.2, s*0.2); ctxAir.lineTo(-s*0.1, s*1.1); ctxAir.lineTo(-s*0.3, s*1.1); ctxAir.lineTo(-s*0.2, s*0.2); ctxAir.fill(); ctxAir.stroke();
                    ctxAir.beginPath(); ctxAir.rect(0, -s*0.7, s*0.4, s*0.25); ctxAir.rect(0, s*0.45, s*0.4, s*0.25); ctxAir.fill(); ctxAir.stroke();
                    ctxAir.beginPath(); ctxAir.lineWidth = 2; ctxAir.moveTo(-s*0.5, 0); ctxAir.lineTo(-s*0.7, -s*0.5); ctxAir.moveTo(-s*0.5, 0); ctxAir.lineTo(-s*0.7, s*0.5); ctxAir.moveTo(-s*0.6, -s*0.5); ctxAir.lineTo(-s*0.8, -s*0.5); ctxAir.moveTo(-s*0.6, s*0.5); ctxAir.lineTo(-s*0.8, s*0.5); ctxAir.stroke();
                } else {
                    ctxAir.fillStyle = "#fff"; ctxAir.strokeStyle = COLOR_HEX[p.team]; ctxAir.lineWidth = 1.5;
                    let fs = s * 0.7; 
                    ctxAir.beginPath(); ctxAir.moveTo(fs*1.3, 0); ctxAir.lineTo(fs*0.3, -fs*0.15); ctxAir.lineTo(0, -fs*1.2); ctxAir.lineTo(-fs*0.3, -fs*1.2); ctxAir.lineTo(-fs*0.4, -fs*0.2); ctxAir.lineTo(-fs*1.0, -fs*0.1); ctxAir.lineTo(-fs*1.2, -fs*0.4); ctxAir.lineTo(-fs*1.3, 0); ctxAir.lineTo(-fs*1.2, fs*0.4); ctxAir.lineTo(-fs*1.0, fs*0.1); ctxAir.lineTo(-fs*0.4, fs*0.2); ctxAir.lineTo(-fs*0.3, fs*1.2); ctxAir.lineTo(0, fs*1.2); ctxAir.lineTo(fs*0.3, fs*0.15); ctxAir.closePath(); ctxAir.fill(); ctxAir.stroke();
                }
                ctxAir.restore();
            });
        }

        function applyNationalLoss(teamId, amount) {
            let multiplier = 0.5 + (Math.random() * 1.5); 
            amount = Math.floor(amount * multiplier);
            let ownedCells = []; 
            for(let y=0; y<ROWS; y++) for(let x=0; x<COLS; x++) if (warGrid[y][x] === teamId) ownedCells.push({x:x, y:y});
            
            if (ownedCells.length > 0) {
                if(teamId == smallestTeamId) amount = Math.floor(amount * 0.5);
                let distCount = Math.max(3, Math.min(50, Math.floor(ownedCells.length * 0.1))); 
                let lossPerSpot = Math.ceil(amount / distCount);

                for(let i=0; i<distCount; i++) {
                    let rndIndex = Math.floor(Math.random() * ownedCells.length);
                    let rnd = ownedCells[rndIndex];
                    populationGrid[rnd.y][rnd.x] = Math.max(0, populationGrid[rnd.y][rnd.x] - lossPerSpot);
                }
            }
            totalCasualties[teamId] += amount;
        }

        function calculateStats() {
            [...TEAMS, REBEL].forEach(id => { 
                teamStats[id].gdp = 0; teamStats[id].totalPop = 0; teamStats[id].size = 0; 
                teamStats[id].totalFrontCount = 0; teamStats[id].realFrontCount = 0; 
            });
            let strBonus = {}; TEAMS.forEach(t=>strBonus[t]=0);
            strategicPoints.forEach(pt => { let owner = warGrid[pt.y][pt.x]; if (owner !== GREY && owner !== OCEAN) strBonus[owner] = (strBonus[owner]||0) + 0.05; });
            
            for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) {
                const owner = warGrid[y][x]; if (owner === GREY || owner === OCEAN) continue;
                
                let efficiency = 0.05; 
                if (demoGrid[y][x] === owner) {
                    let lvl = (coreLevelGrid[y] && coreLevelGrid[y][x] !== undefined) ? coreLevelGrid[y][x] : 0;
                    if (lvl === 3) efficiency = 1.0;
                    else if (lvl === 2) efficiency = 0.50;
                    else if (lvl === 1) efficiency = 0.25;
                    else efficiency = 0.05;
                }
                
                teamStats[owner].totalPop += Math.floor(populationGrid[y][x] * efficiency);
                teamStats[owner].gdp += (GDP_PER_CELL * efficiency);
                teamStats[owner].size++;

                let dirs = [[0,1],[0,-1],[1,0],[-1,0]];
                for(let d of dirs) {
                    let ny = y + d[0]; let nx = x + d[1];
                    if(ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
                        let neighborId = warGrid[ny][nx];
                        if(neighborId !== owner && neighborId !== OCEAN && !areAllies(owner, neighborId)) { 
                             teamStats[owner].totalFrontCount++;
                             if (neighborId !== GREY) {
                                 teamStats[owner].realFrontCount++; 
                             }
                        }
                    }
                }
            }
            
            let minPop = Infinity; smallestTeamId = null;
            TEAMS.forEach(t => { if(teamStats[t].totalPop > 0 && teamStats[t].totalPop < minPop) { minPop = teamStats[t].totalPop; smallestTeamId = t; } });
            
            [...TEAMS, REBEL].forEach(id => { 
                let randomFlux = 0.8 + Math.random() * 0.4;
                teamStats[id].money += (teamStats[id].gdp * randomFlux); 
                if (teamStats[id].factories > 0 && id !== REBEL) {
                     let cost = NUKE_COST_PER_TICK;
                     if(teamStats[id].money > cost) {
                        teamStats[id].money -= cost;
                        teamStats[id].nukeProgress += (0.05 * teamStats[id].factories); 
                        if(teamStats[id].nukeProgress >= NUKE_THRESHOLD) launchNuke(id);
                     }
                }
                if(id !== REBEL) {
                    let cost = getCurrentFactoryCost(id);
                    let maxFac = Math.max(1, Math.floor(teamStats[id].size / 5));
                    if(teamStats[id].money >= cost && teamStats[id].factories < maxFac) {
                        if(Math.random() < 0.01) { buyFactory(id); }
                    }
                }
            });
            return strBonus;
        }

        function launchNuke(attackerId) {
            let targets = TEAMS.filter(t => t !== attackerId && teamStats[t].totalPop > 1000 && !areAllies(attackerId, t));
            if(targets.length === 0) return;
            targets.sort((a,b) => teamStats[b].totalPop - teamStats[a].totalPop);
            let targetId = targets[0];
            let cap = CAPITALS[targetId];
            let targetX, targetY;
            if(cap) { targetX = cap.x; targetY = cap.y; } else { for(let y=0; y<ROWS; y++) for(let x=0; x<COLS; x++) if(warGrid[y][x]===targetId) { targetX=x; targetY=y; break; } }

            if(targetX !== undefined) {
                triggerNukeEffect();
                addLog(`â˜¢ï¸ ${BASE_TEAM_NAMES[attackerId]} NUKED ${BASE_TEAM_NAMES[targetId]} (2x2 Grid)!`, 'nuke');
                let offsets = [{dx:0, dy:0}, {dx:1, dy:0}, {dx:0, dy:1}, {dx:1, dy:1}];
                offsets.forEach(off => {
                    let nx = targetX + off.dx; let ny = targetY + off.dy;
                    if(ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
                        let victim = warGrid[ny][nx];
                        if(factoryGrid[ny][nx] === 1) { factoryGrid[ny][nx] = 0; if(victim !== GREY && victim !== OCEAN) teamStats[victim].factories = Math.max(0, teamStats[victim].factories - 1); }
                        if (warGrid[ny][nx] !== OCEAN) {
                            warGrid[ny][nx] = GREY; populationGrid[ny][nx] = 0; occupationTime[ny][nx] = 0;
                            startCaptureAnimation(nx, ny, targetId, GREY, nx, ny);
                        }
                    }
                });
                if(cap) delete CAPITALS[targetId]; teamStats[attackerId].nukeProgress = 0; 
            }
        }

        function triggerModernEraCollapse() {
            let biggestTeam = TEAMS.reduce((a, b) => (teamStats[a].totalPop > teamStats[b].totalPop ? a : b));
            if (teamStats[biggestTeam].totalPop < 5000) return; 
            addLog(`ðŸ“‰ 1950 CRISIS: ${BASE_TEAM_NAMES[biggestTeam]} is collapsing into civil war!`, 'annihilation');
            let cells = [];
            for(let y=0; y<ROWS; y++) for(let x=0; x<COLS; x++) if(warGrid[y][x] === biggestTeam) cells.push({x,y});
            let centerX = cells.reduce((sum, c) => sum + c.x, 0) / cells.length;
            let centerY = cells.reduce((sum, c) => sum + c.y, 0) / cells.length;
            let otherTeams = TEAMS.filter(t => t !== biggestTeam);
            otherTeams.sort((a,b) => teamStats[a].totalPop - teamStats[b].totalPop);
            let newStates = [biggestTeam, otherTeams[0], otherTeams[1], otherTeams[2]];
            cells.forEach(c => {
                let regionIndex = 0;
                if (c.x < centerX && c.y < centerY) regionIndex = 0; 
                else if (c.x >= centerX && c.y < centerY) regionIndex = 1; 
                else if (c.x < centerX && c.y >= centerY) regionIndex = 2; 
                else regionIndex = 3; 
                let newOwner = newStates[regionIndex];
                if (newOwner !== biggestTeam) {
                    warGrid[c.y][c.x] = newOwner; occupationTime[c.y][c.x] = 0;
                    populationGrid[c.y][c.x] = Math.floor(populationGrid[c.y][c.x] * 0.7);
                    startCaptureAnimation(c.x, c.y, biggestTeam, newOwner, c.x, c.y);
                }
            });
            newStates.forEach(id => relocateCapital(id));
        }

        function createFactoryBarElement(id, name, container) {
            const wrapper = document.createElement('div'); wrapper.className = 'bar-wrapper'; 
            const info = document.createElement('div'); info.className = 'bar-info';
            const nameEl = document.createElement('div'); nameEl.className = 'bar-name'; nameEl.innerText = name; nameEl.style.color = COLOR_HEX[id];
            const moneyEl = document.createElement('div'); moneyEl.className = 'bar-money'; moneyEl.id = `money-${id}`; moneyEl.innerText = '$0';
            info.appendChild(nameEl); info.appendChild(moneyEl);
            const actions = document.createElement('div'); actions.className = 'bar-actions';
            const nukeContainer = document.createElement('div'); nukeContainer.style.display = 'flex'; nukeContainer.style.flexDirection = 'column'; nukeContainer.style.alignItems='center';
            const nukeLabel = document.createElement('div'); nukeLabel.innerText = "â˜¢ï¸"; nukeLabel.style.fontSize='10px';
            const nukeBar = document.createElement('div'); nukeBar.className = 'nuke-progress';
            const nukeFill = document.createElement('div'); nukeFill.className = 'nuke-fill'; nukeFill.id = `nuke-fill-${id}`;
            nukeBar.appendChild(nukeFill); nukeContainer.appendChild(nukeLabel); nukeContainer.appendChild(nukeBar);
            const fCount = document.createElement('div'); fCount.className = 'factory-count'; fCount.id = `factories-${id}`; fCount.innerText = '0';
            const btn = document.createElement('button'); btn.className = 'btn-buy-factory'; btn.innerText = '+FACTORY'; btn.onclick = () => buyFactory(id); btn.id = `btn-buy-${id}`;
            actions.appendChild(nukeContainer); actions.appendChild(fCount); actions.appendChild(btn); wrapper.appendChild(info); wrapper.appendChild(actions); container.appendChild(wrapper); 
        }

        function createDraftElement(id, name, container) {
            const wrapper = document.createElement('div'); wrapper.className = 'bar-wrapper'; wrapper.style.height = '25px';
            const nameEl = document.createElement('div'); nameEl.className = 'bar-name'; nameEl.innerText = name; nameEl.style.color = COLOR_HEX[id]; nameEl.style.width = '50%';
            const rateEl = document.createElement('div'); rateEl.className = 'bar-money'; rateEl.id = `draft-rate-${id}`; rateEl.innerText = '2.0%'; rateEl.style.width = '50%'; rateEl.style.textAlign = 'right'; rateEl.style.paddingRight = '10px';
            wrapper.appendChild(nameEl); wrapper.appendChild(rateEl); container.appendChild(wrapper); 
        }

        function buyFactory(teamId) {
            let stats = teamStats[teamId];
            let cost = getCurrentFactoryCost(teamId);
            let maxFactories = Math.max(1, Math.floor(stats.size / 5));
            if (stats.factories >= maxFactories) return;
            if(stats.money >= cost) {
                let validSpots = [];
                for(let y=0; y<ROWS; y++) for(let x=0; x<COLS; x++) if(warGrid[y][x] === teamId && factoryGrid[y][x] === 0 && demoGrid[y][x] === teamId) validSpots.push({x:x, y:y});
                if(validSpots.length > 0) {
                    teamStats[teamId].money -= cost;
                    let spot = validSpots[Math.floor(Math.random() * validSpots.length)];
                    factoryGrid[spot.y][spot.x] = 1; teamStats[teamId].factories++;
                    updateEconomyUI(); addLog(`${BASE_TEAM_NAMES[teamId]} built a Factory ($${Math.floor(cost/1000)}k).`, 'normal');
                }
            }
        }

        function updateEconomyUI() {
            [...TEAMS, REBEL].forEach(id => {
                let moneyEl = document.getElementById(`money-${id}`); let fCountEl = document.getElementById(`factories-${id}`); let btn = document.getElementById(`btn-buy-${id}`); let nukeFill = document.getElementById(`nuke-fill-${id}`);
                let currentCost = getCurrentFactoryCost(id);
                if(moneyEl) moneyEl.innerText = `$${Math.floor(teamStats[id].money).toLocaleString()}`;
                if(fCountEl) fCountEl.innerText = `ðŸ­ ${teamStats[id].factories}`;
                if(btn) { btn.innerText = `+FACT ($${Math.floor(currentCost/1000)}k)`; btn.disabled = teamStats[id].money < currentCost; }
                if(nukeFill) nukeFill.style.width = Math.min(teamStats[id].nukeProgress, 100) + '%';
            });
        }

        function updateDraftUI() {
            [...TEAMS, REBEL].forEach(id => {
                let el = document.getElementById(`draft-rate-${id}`);
                if(el) {
                    let baseRate = 0.02; let factoryBonus = (teamStats[id].factories || 0) * 0.001; let finalRate = baseRate + factoryBonus;
                    if(id === REBEL) finalRate = 0.15; el.innerText = (finalRate * 100).toFixed(1) + '%';
                }
            });
        }
        
        function updateAllBars() {
            let popData = [...TEAMS, REBEL].map(id => ({id:id, val:teamStats[id].totalPop / 1000})); updateBarSystem(popData, 'pop', 'k');
            let lossData = [...TEAMS, REBEL].map(id => ({id:id, val:totalCasualties[id] / 1000})); updateBarSystem(lossData, 'loss', 'k');
        }

        function updateBarSystem(data, prefix, unit) {
            data.sort((a,b) => b.val - a.val); let max = Math.max(...data.map(d=>d.val), 1);
            data.forEach((d, i) => {
                let w = document.getElementById(`${prefix}-wrapper-${d.id}`); let f = document.getElementById(`${prefix}-fill-${d.id}`); let v = document.getElementById(`${prefix}-value-${d.id}`);
                w.style.top = (i * 22) + 'px'; f.style.width = ((d.val/max)*100)+'%'; v.innerText = (d.val >= 1000 ? (d.val/1000).toFixed(1)+'M' : Math.floor(d.val)+unit);
            });
        }
        
        function updateView() {
            if(!ctxDemo || !ctxPop || !ctxFact) return; 

            const dCW = demoCanvas.width / COLS; const dCH = demoCanvas.height / ROWS;
            ctxDemo.clearRect(0, 0, demoCanvas.width, demoCanvas.height);
            
            const pCW = popCanvas.width / COLS; const pCH = popCanvas.height / ROWS;
            ctxPop.clearRect(0, 0, popCanvas.width, popCanvas.height);

            const fCW = factoryCanvas.width / COLS; const fCH = factoryCanvas.height / ROWS;
            ctxFact.clearRect(0, 0, factoryCanvas.width, factoryCanvas.height);

            for(let y=0; y<ROWS; y++) for(let x=0; x<COLS; x++) {
                // --- POLITICAL MAP ---
                let occupier = warGrid[y][x]; 
                let native = demoGrid[y][x];
                
                if (occupier === OCEAN) {
                    ctxDemo.fillStyle = COLOR_HEX[OCEAN];
                } else if (occupier === GREY) {
                    ctxDemo.fillStyle = '#111'; 
                } else if (occupier !== native) {
                    ctxDemo.fillStyle = COLOR_HEX[native];
                    ctxDemo.fillRect(x*dCW, y*dCH, dCW, dCH);
                    ctxDemo.fillStyle = COLOR_HEX[occupier];
                    ctxDemo.globalAlpha = 0.5; 
                } else {
                    ctxDemo.fillStyle = COLOR_HEX[native];
                    ctxDemo.globalAlpha = 1.0;
                }
                ctxDemo.fillRect(x*dCW, y*dCH, dCW, dCH);
                ctxDemo.globalAlpha = 1.0;

                if (permanentCoreGrid[y][x]) {
                    ctxDemo.strokeStyle = 'gold'; ctxDemo.lineWidth = 1;
                    ctxDemo.strokeRect(x*dCW, y*dCH, dCW, dCH);
                }

                // --- POPULATION MAP ---
                if (occupier !== OCEAN) {
                    let pop = populationGrid[y][x];
                    let ratio = Math.min(pop / INITIAL_POPULATION, 1);
                    let r = Math.floor(ratio * 255);
                    ctxPop.fillStyle = `rgb(${r}, 0, 0)`;
                    ctxPop.fillRect(x*pCW, y*pCH, pCW, pCH);
                    if (pop > 5000) {
                        ctxPop.fillStyle = 'rgba(255,255,255,0.9)'; 
                        ctxPop.font = 'bold 8px Arial'; 
                        ctxPop.textAlign = 'center'; ctxPop.textBaseline = 'middle';
                        ctxPop.fillText(Math.floor(pop / 1000), x*pCW + pCW/2, y*pCH + pCH/2);
                    }
                } else {
                    ctxPop.fillStyle = COLOR_HEX[OCEAN];
                    ctxPop.fillRect(x*pCW, y*pCH, pCW, pCH);
                }

                // --- FACTORY MAP ---
                if (factoryGrid[y][x] === 1) {
                    let owner = warGrid[y][x];
                    ctxFact.fillStyle = (owner !== GREY && owner !== OCEAN) ? COLOR_HEX[owner] : '#555';
                    ctxFact.fillRect(x*fCW, y*fCH, fCW, fCH);
                    ctxFact.strokeStyle = 'white'; ctxFact.lineWidth = 0.5;
                    ctxFact.strokeRect(x*fCW, y*fCH, fCW, fCH);
                }
            }
            updateLabels(); updateAllBars();
        }

        function updateLabels() {
            let fronts = {}; 
            for(let y=0; y<ROWS; y++) for(let x=0; x<COLS; x++) {
                let c1 = warGrid[y][x]; if(c1===GREY || c1===OCEAN) continue;
                [{y:y,x:x+1}, {y:y+1,x:x}].forEach(n => {
                    if(n.y<ROWS && n.x<COLS) {
                        let c2 = warGrid[n.y][n.x];
                        if(c2!==c1 && c2!==OCEAN && !areAllies(c1, c2)) {
                            let key = c1<c2 ? `${c1}-${c2}` : `${c2}-${c1}`;
                            if(!fronts[key]) fronts[key] = {[c1]:{x:0,y:0,n:0,troops:0}, [c2]:{x:0,y:0,n:0,troops:0}};
                            
                            let force1 = getArmyForce(c1, c2 !== GREY);
                            let force2 = getArmyForce(c2, c1 !== GREY);

                            fronts[key][c1].x+=x; fronts[key][c1].y+=y; fronts[key][c1].n++; fronts[key][c1].troops+=force1;
                            fronts[key][c2].x+=n.x; fronts[key][c2].y+=n.y; fronts[key][c2].n++; fronts[key][c2].troops+=force2;
                        }
                    }
                });
            }
            for(let k in fronts) { for(let t in fronts[k]) { fronts[k][t].avgX = fronts[k][t].x / fronts[k][t].n; fronts[k][t].avgY = fronts[k][t].y / fronts[k][t].n; } }
            currentFrontData = fronts; 

            let labelData = []; const rect = warCanvas.getBoundingClientRect(); let dynamicCellW = rect.width / COLS; let dynamicCellH = rect.height / ROWS;
            for(let key in fronts) {
                for(let t in fronts[key]) {
                    let d = fronts[key][t]; if(d.n === 0) continue;
                    if(d.troops < 500) continue;
                    let frontID = `front-${key}-${t}`;
                    let progress = frontProgress[frontID] ? frontProgress[frontID].val : 0;
                    let state = frontProgress[frontID] ? frontProgress[frontID].state : 'planning';
                    d.screenX = d.avgX*dynamicCellW + dynamicCellW/2; d.screenY = d.avgY*dynamicCellH + dynamicCellH/2;
                    labelData.push({ id: `l-${key}-${t}`, team: t, x: d.screenX, y: d.screenY, txt: Math.floor(d.troops).toLocaleString('en-US'), progress: progress, state: state });
                }
            }
            labelData.sort((a,b) => a.y - b.y); let placed = [];
            for(let l of labelData) {
                let safe = false, attempts = 0;
                while(!safe && attempts < 10) { safe = true; for(let p of placed) { if(Math.abs(l.x - p.x) < 30 && Math.abs(l.y - p.y) < 20) { l.y += 20; safe = false; break; } } attempts++; }
                placed.push(l); 
                let el = document.getElementById(l.id);
                if(!el) { el = document.createElement('div'); el.id = l.id; el.className = `troop-label ${COLOR_CLASS_LBL[l.team]}`; el.innerHTML = `<span class="t-txt"></span><div class="planning-bar-track"><div class="planning-bar-fill"></div></div>`; labelsLayerEl.appendChild(el); }
                el.style.left = l.x + 'px'; el.style.top = l.y + 'px';
                el.querySelector('.t-txt').innerText = l.txt;
                let bar = el.querySelector('.planning-bar-fill'); bar.style.width = Math.min(l.progress, 100) + '%';
                
                el.classList.remove('regrouping', 'attacking');
                if(l.state === 'regroup') el.classList.add('regrouping');
                if(l.state === 'attacking') el.classList.add('attacking');
            }
            let activeIds = new Set(labelData.map(l=>l.id)); 
            Array.from(labelsLayerEl.children).forEach(c => { if(!c.classList.contains('blitz-text') && !c.classList.contains('blitz-result') && !c.classList.contains('panic-text') && !c.classList.contains('annihilate-text') && !activeIds.has(c.id)) labelsLayerEl.removeChild(c); });
        }
        
        function countFriendly(y, x, c, g) { let n = 0; const dirs = [[0,1],[0,-1],[1,0],[-1,0]]; dirs.forEach(d=>{ let ny=y+d[0], nx=x+d[1]; if(ny>=0 && ny<ROWS && nx>=0 && nx<COLS && g[ny][nx]===c) n++; }); return n; }

        function checkRebellion() {
            if(teamStats[REBEL].totalPop > 0) return; let totalCells = ROWS * COLS; let counts = {};
            for(let y=0; y<ROWS; y++) for(let x=0; x<COLS; x++) { let c=warGrid[y][x]; counts[c] = (counts[c]||0)+1; }
            for(let t of TEAMS) {
                if(counts[t] > totalCells * 0.55 && Math.random() < 0.01) { 
                    let spots = []; for(let i=0; i<50; i++) { let rx=Math.floor(Math.random()*COLS); let ry=Math.floor(Math.random()*ROWS); if(warGrid[ry][rx] === t) spots.push({x:rx, y:ry}); }
                    if(spots.length > 0) {
                        let center = spots[0]; let size = 4; 
                        for(let dy=0; dy<size; dy++) for(let dx=0; dx<size; dx++) {
                            let ny = center.y + dy; let nx = center.x + dx;
                            if(ny < ROWS && nx < COLS) { startCaptureAnimation(nx, ny, warGrid[ny][nx], REBEL, nx, ny); warGrid[ny][nx] = REBEL; demoGrid[ny][nx] = REBEL; occupationTime[ny][nx] = 0; }
                        }
                        rebelSafeTimer = REBEL_PEACE_TIME; 
                        addLog(`${BASE_TEAM_NAMES[t]} faces a REBELLION!`, 'rebel');
                    }
                }
            }
        }

        function updateDiplomacyLogic() {
            for (let key in alliances) {
                alliances[key]--;
                if (alliances[key] <= 0) { delete alliances[key]; let ids = key.split('-'); addLog(`Pact expired: ${BASE_TEAM_NAMES[ids[0]]} - ${BASE_TEAM_NAMES[ids[1]]}`, 'war'); }
            }

            if (gameTick % 40 === 0) { 
                let activeTeams = TEAMS.filter(t => teamStats[t].totalPop > 0);
                if (activeTeams.length > 1) {
                    let t1 = activeTeams[Math.floor(Math.random() * activeTeams.length)];
                    let t2 = activeTeams[Math.floor(Math.random() * activeTeams.length)];
                    
                    if (t1 !== t2 && !areAllies(t1, t2)) {
                        let chance = 0.05; 
                        if (simDate.getFullYear() < 1936) {
                            chance = 0.60; 
                        }
                        if (totalCasualties[t1] > 20000) chance += 0.1;
                        if (totalCasualties[t2] > 20000) chance += 0.1;

                        if (Math.random() < chance) {
                            let duration = 400 + Math.floor(Math.random() * 400); 
                            let key = getAllianceKey(t1, t2);
                            alliances[key] = duration;
                            addLog(`â˜®ï¸ PACT SIGNED: ${BASE_TEAM_NAMES[t1]} & ${BASE_TEAM_NAMES[t2]}`, 'peace');
                        }
                    }
                }
            }
        }

        function createStatBarElement(id, name, container, prefix) {
            const wrapper = document.createElement('div'); wrapper.className = 'stat-bar-wrapper'; wrapper.id = `${prefix}-wrapper-${id}`; 
            const label = document.createElement('div'); label.className = 'stat-bar-label'; label.innerText = name; wrapper.appendChild(label); 
            const track = document.createElement('div'); track.className = 'stat-bar-track'; 
            const fill = document.createElement('div'); fill.className = `stat-bar-fill ${COLOR_CLASS_BG[id]}`; fill.id = `${prefix}-fill-${id}`; fill.style.width = '0%'; 
            const val = document.createElement('div'); val.className = 'stat-bar-value'; val.id = `${prefix}-value-${id}`; val.innerText = '0'; fill.appendChild(val); 
            track.appendChild(fill); wrapper.appendChild(track); container.appendChild(wrapper); 
        }

        function relocateCapital(id) {
            let spots = []; for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++) if(warGrid[y][x]===id) spots.push({x,y});
            if(spots.length>0) { CAPITALS[id] = spots[Math.floor(Math.random()*spots.length)]; addLog(`${BASE_TEAM_NAMES[id]} moved Capital!`, 'normal'); }
            else { delete CAPITALS[id]; addLog(`${BASE_TEAM_NAMES[id]} HAS FALLEN!`, 'war'); }
        }

        function resetGame() { clearInterval(intervalId); createBoards(); isPaused=false; document.getElementById('btn-pause').innerText="Pause"; document.body.classList.add('running'); intervalId=setInterval(gameLoop, currentSpeed); }
        function togglePause() { if(isPaused) { isPaused=false; intervalId=setInterval(gameLoop, currentSpeed); this.innerText="Pause"; } else { isPaused=true; clearInterval(intervalId); this.innerText="Resume"; } }
        
        function spawnPlane(teamId, forcedType = null) {
            if (teamId === REBEL) return;
            const cap = CAPITALS[teamId]; if (!cap) return; if (warGrid[cap.y][cap.x] !== teamId) return;
            let currentPlanes = planes.filter(p => p.team === teamId);
            let bC = currentPlanes.filter(p => p.type === 'BOMBER').length; let fC = currentPlanes.filter(p => p.type === 'FIGHTER').length;
            let type = forcedType;
            if (!type) { if (bC < 2 && fC < 3) type = Math.random() < 0.6 ? 'BOMBER' : 'FIGHTER'; else if (bC < 2) type = 'BOMBER'; else if (fC < 3) type = 'FIGHTER'; else return; } 
            let newPlane = { team: teamId, type: type, gridX: cap.x, gridY: cap.y, originGX: cap.x, originGY: cap.y, state: 'SEARCH', targetPlane: null, targetGX: cap.x, targetGY: cap.y };
            if (type === 'BOMBER') {
                let attempts = 0, found = false;
                while(attempts < 50) {
                    let tx = Math.floor(Math.random() * COLS); let ty = Math.floor(Math.random() * ROWS);
                    let targetTeam = warGrid[ty][tx];
                    if (targetTeam !== teamId && targetTeam !== OCEAN && !areAllies(teamId, targetTeam)) { newPlane.targetGX = tx; newPlane.targetGY = ty; newPlane.state = 'ATTACK'; found = true; break; }
                    attempts++;
                }
                if(!found) return;
            } else { newPlane.state = 'PATROL'; newPlane.targetGX = Math.random() * COLS; newPlane.targetGY = Math.random() * ROWS; }
            planes.push(newPlane);
        }

        function checkLiberation() {
            if (liberationTriggered || simDate.getFullYear() < 1920) return;

            let activePowers = TEAMS.filter(t => teamStats[t].totalPop > 1000);
            
            if (activePowers.length <= 2) {
                liberationTriggered = true; 
                addLog("âš–ï¸ BALANCE OF POWER: The oppressed nations are rising!", "annihilation");
                addLog("ðŸ•Šï¸ BORDERS RESTORED to Political Map!", "peace");

                let liberatedTeams = TEAMS.filter(t => !activePowers.includes(t));
                let restorationCount = 0;

                for(let y=0; y<ROWS; y++) for(let x=0; x<COLS; x++) {
                    let nativeOwner = demoGrid[y][x];    
                    let occupier = warGrid[y][x];        

                    if (nativeOwner !== GREY && nativeOwner !== OCEAN && nativeOwner !== occupier && !activePowers.includes(nativeOwner)) {
                        warGrid[y][x] = nativeOwner; 
                        occupationTime[y][x] = 0;
                        startCaptureAnimation(x, y, occupier, nativeOwner, x, y);

                        if (factoryGrid[y][x] === 1) {
                            if (teamStats[occupier]) teamStats[occupier].factories = Math.max(0, teamStats[occupier].factories - 1);
                            teamStats[nativeOwner].factories++;
                        }
                        if (populationGrid[y][x] < 500) populationGrid[y][x] = 500;
                        restorationCount++;
                    }
                }

                liberatedTeams.forEach(teamId => {
                    let landCount = 0;
                    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(warGrid[y][x]===teamId) landCount++;

                    if (landCount > 0) {
                        if (window.BACKUP_CAPITALS && window.BACKUP_CAPITALS[teamId]) {
                            CAPITALS[teamId] = window.BACKUP_CAPITALS[teamId];
                            let c = CAPITALS[teamId];
                            warGrid[c.y][c.x] = teamId; 
                        } else {
                            relocateCapital(teamId);
                        }
                        teamStats[teamId].money += 5000; 
                        if(CAPITALS[teamId]) {
                            spawnParticles(CAPITALS[teamId].x * (warCanvas.width/COLS), CAPITALS[teamId].y * (warCanvas.height/ROWS), 'confetti');
                        }
                        addLog(`ðŸš© ${BASE_TEAM_NAMES[teamId]} restored independence!`, 'rebel');
                    }
                });
                updateLabels();
            }
        }
        function checkVictory() {
            let active = TEAMS.filter(t => teamStats[t].totalPop > 100);
            if (active.length === 1 && gameTick > 300) {
                victoryScreen.style.display = 'flex';
                victoryText.innerText = `WINNER: ${BASE_TEAM_NAMES[active[0]]}`;
                clearInterval(intervalId);
            }
        }

        // --- ANA OYUN DÃ–NGÃœSÃœ ---
        function gameLoop() {
            gameTick++;
            simDate.setDate(simDate.getDate() + 2);
            
            let year = simDate.getFullYear();
            let month = (simDate.getMonth() + 1).toString().padStart(2, '0');
            let day = simDate.getDate().toString().padStart(2, '0');
            document.getElementById('date-display').innerText = `${year}-${month}-${day}`;

            let eraName = "TRENCH WARFARE"; let eraColor = "#f1c40f"; let cooldownLimit = 60; let isModernWar = false;

            if (year >= GAME_CONFIG.modern.start) {
                eraName = "MODERN ERA"; eraColor = "#3498db"; cooldownLimit = 20; isModernWar = true;
                if (!modernEraTriggered) { triggerModernEraCollapse(); modernEraTriggered = true; addLog("ðŸŒ WELCOME TO THE MODERN ERA", "annihilation"); }
            } else if (year >= GAME_CONFIG.mobile.start) {
                eraName = "MOBILE WARFARE"; eraColor = "#e67e22"; cooldownLimit = 30; isModernWar = true;
            }

            let eraEl = document.getElementById('era-display');
            if(eraEl.innerText !== eraName) { 
                eraEl.innerText = eraName; 
                eraEl.style.color = eraColor; 
                if(year === GAME_CONFIG.mobile.start) addLog("âš¡ DOCTRINE CHANGE: Blitzkrieg tactics enabled!", "blitz"); 
            }

            if (gameTick % 60 === 0) {
                updateCoreProgression();
            }

            if(rebelSafeTimer > 0) { rebelSafeTimer--; if(rebelSafeTimer === 0) addLog("Rebels launching full assault!", 'rebel'); }
            updateDiplomacyLogic(); 
            
            if (year >= GAME_CONFIG.mobile.start) checkBlitz();

            let newWarGrid = JSON.parse(JSON.stringify(warGrid));
            let activeCells = []; 
            for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) if (warGrid[y][x] !== GREY && warGrid[y][x] !== OCEAN) activeCells.push({y: y, x: x, c: warGrid[y][x]});
            activeCells.sort(() => Math.random() - 0.5);
            
            calculateStats(); 

            activeCells.forEach(cell => {
                if(rebelSafeTimer > 0 && cell.c === REBEL) return;

                let neighbors = [{y:cell.y-1,x:cell.x}, {y:cell.y+1,x:cell.x}, {y:cell.y,x:cell.x-1}, {y:cell.y,x:cell.x+1}]
                                .filter(n => n.y>=0 && n.y<ROWS && n.x>=0 && n.x<COLS);
                if(neighbors.length === 0) return;

                let hasGreyNeighbor = neighbors.some(n => warGrid[n.y][n.x] === GREY);
                let requiredCooldown = hasGreyNeighbor ? 5 : cooldownLimit;
                if (occupationTime[cell.y][cell.x] < requiredCooldown) return; 
                
                let target = neighbors[Math.floor(Math.random()*neighbors.length)];
                let targetC = warGrid[target.y][target.x];
                
                // --- DENÄ°ZE SALDIRMA ---
                if (targetC === OCEAN) return;
                
                if(rebelSafeTimer > 0 && targetC === REBEL) return;
                if(targetC === cell.c || areAllies(cell.c, targetC)) return;

                // --- SAVAÅž GÃœCÃœ HESAPLAMA ---
                let isRealWar = (targetC !== GREY);
                let atkArmy = getArmyForce(cell.c, isRealWar);
                
                let neutralResistance = 20; 
                let defArmy = (targetC !== GREY) ? getArmyForce(targetC, true) : neutralResistance;

                if(targetC !== GREY && CAPITALS[targetC] && CAPITALS[targetC].x === target.x && CAPITALS[targetC].y === target.y) { 
                    defArmy *= GAME_CONFIG.modifiers.capital; 
                }

                if (year < GAME_CONFIG.mobile.start) {
                    defArmy *= GAME_CONFIG.modifiers.trench_def;
                } else {
                    defArmy *= 1.1; 
                }

                if (targetC !== GREY && teamStats[targetC] && teamStats[targetC].size <= 10) {
                    defArmy *= GAME_CONFIG.modifiers.small;
                }

                let minMult, maxMult;
                if (year >= GAME_CONFIG.modern.start) {
                    minMult = GAME_CONFIG.modern.min;
                    maxMult = GAME_CONFIG.modern.max;
                } else if (year >= GAME_CONFIG.mobile.start) {
                    minMult = GAME_CONFIG.mobile.min;
                    maxMult = GAME_CONFIG.mobile.max;
                } else {
                    minMult = GAME_CONFIG.trench.min;
                    maxMult = GAME_CONFIG.trench.max;
                }

                // --- ARAZÄ° BONUSLARI ---
                let terrainType = terrainGrid[target.y][target.x];
                if (terrainType === TERRAIN_MOUNTAIN) {
                    defArmy *= 3.0; 
                    if (Math.random() < 0.005) addLog(`â›°ï¸ Mountain defense at [${target.x},${target.y}] holds!`, 'normal');
                } else if (terrainType === TERRAIN_FOREST) {
                    defArmy *= 1.5; 
                }

                let atkLuck = minMult + Math.random() * (maxMult - minMult);
                let defLuck = minMult + Math.random() * (maxMult - minMult);

                if (maxMult > 1.5 && Math.random() < 0.1) atkLuck *= 1.5; 

                let atkRoll = atkArmy * atkLuck;
                let defRoll = defArmy * defLuck;
                
                if(atkRoll > defRoll) {
                    if (year < GAME_CONFIG.mobile.start && atkRoll < defRoll * 1.1 && targetC !== GREY) {
                         applyNationalLoss(cell.c, BASE_LOSS * 1.5); applyNationalLoss(targetC, BASE_LOSS * 0.5); return; 
                    }

                    if(targetC !== GREY && CAPITALS[targetC] && CAPITALS[targetC].x === target.x && CAPITALS[targetC].y === target.y) relocateCapital(targetC);
                    
                    let attackerLoss = (year >= GAME_CONFIG.mobile.start) ? BASE_LOSS * 2.0 : BASE_LOSS * 1.5;
                    applyNationalLoss(cell.c, attackerLoss); 
                    if(targetC !== GREY) applyNationalLoss(targetC, BASE_LOSS); 

                    let currentPop = populationGrid[target.y][target.x]; 
                    let devastation = Math.floor(currentPop * 0.05); 
                    populationGrid[target.y][target.x] = Math.max(0, currentPop - devastation);
                    
                    if(newWarGrid[target.y][target.x] !== cell.c) {
                        if (factoryGrid[target.y][target.x] === 1) {
                            if (targetC !== GREY) teamStats[targetC].factories = Math.max(0, teamStats[targetC].factories - 1);
                            teamStats[cell.c].factories++;
                            addLog(`ðŸ­ ${BASE_TEAM_NAMES[cell.c]} captured a factory!`, 'normal');
                        }
                        startCaptureAnimation(target.x, target.y, targetC, cell.c, cell.x, cell.y);
                        newWarGrid[target.y][target.x] = cell.c; 
                        occupationTime[target.y][target.x] = 0;
                    }
                } else { 
                    applyNationalLoss(cell.c, BASE_LOSS); 
                }
            });

            // GRID UPDATE
            warGrid = newWarGrid;
            for(let y=0; y<ROWS; y++) for(let x=0; x<COLS; x++) {
                let owner = warGrid[y][x];
                if(owner !== GREY && owner !== OCEAN) {
                    occupationTime[y][x]++; 
                    if(permanentCoreGrid[y] && permanentCoreGrid[y][x]) continue; 
                }
            }
            checkRebellion(); updatePlanes(); updateFleets();
            updateView(); updateEconomyUI(); updateDraftUI(); 
            checkLiberation(); 
            checkVictory();
        }
    });
    </script>
</body>
</html>